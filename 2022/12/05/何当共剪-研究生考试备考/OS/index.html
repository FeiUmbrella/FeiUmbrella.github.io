<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>操作系统-期末考试 | Umbrella's Blog</title><meta name="author" content="Umbrella"><meta name="copyright" content="Umbrella"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="OS - 大三上备考 第一章：绪论 操作系统的地位，作用，定义  定义：  操作系统是管理和控制计算机系统中的全部软件、硬件资源，合理地 组织计算机的工作流程，为用户应用程序的运行提供一个友好的界面 和良好的工作环境的系统软件  Or  操作系统是直接管理和控制计算机硬件、软件资源，合理地对各类作 业进行调度，以方便用户使用的程序的集合。  Or  操作系统是一组">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统-期末考试">
<meta property="og:url" content="http://example.com/2022/12/05/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/OS/index.html">
<meta property="og:site_name" content="Umbrella&#39;s Blog">
<meta property="og:description" content="OS - 大三上备考 第一章：绪论 操作系统的地位，作用，定义  定义：  操作系统是管理和控制计算机系统中的全部软件、硬件资源，合理地 组织计算机的工作流程，为用户应用程序的运行提供一个友好的界面 和良好的工作环境的系统软件  Or  操作系统是直接管理和控制计算机硬件、软件资源，合理地对各类作 业进行调度，以方便用户使用的程序的集合。  Or  操作系统是一组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg">
<meta property="article:published_time" content="2022-12-05T07:40:00.000Z">
<meta property="article:modified_time" content="2022-12-08T10:04:00.000Z">
<meta property="article:author" content="Umbrella">
<meta property="article:tag" content="期末考试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg"><link rel="shortcut icon" href="https://img-blog.csdnimg.cn/23699fd36f8949b98f0122ad5eb74556.png"><link rel="canonical" href="http://example.com/2022/12/05/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/OS/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统-期末考试',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2022-12-08 18:04:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://img-blog.csdnimg.cn/4500002a681d49c586c22a88e4ec5868.bmp" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Umbrella's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统-期末考试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-05T07:40:00.000Z" title="发表于 2022-12-05 15:40:00">2022-12-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-08T10:04:00.000Z" title="更新于 2022-12-08 18:04:00">2022-12-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA/">何当共剪</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统-期末考试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="os---大三上备考">OS - 大三上备考</h1>
<h2 id="第一章绪论">第一章：绪论</h2>
<h3 id="操作系统的地位作用定义">操作系统的地位，作用，定义</h3>
<blockquote>
<p><code>定义</code>：</p>
<ul>
<li>操作系统是管理和控制计算机系统中的全部软件、硬件资源，合理地
组织计算机的工作流程，为用户应用程序的运行提供一个友好的界面
和良好的工作环境的系统软件</li>
</ul>
<p><code>Or</code></p>
<ul>
<li>操作系统是直接管理和控制计算机硬件、软件资源，合理地对各类作
业进行调度，以方便用户使用的程序的集合。</li>
</ul>
<p><code>Or</code></p>
<ul>
<li>操作系统是一组管理与控制计算机软硬件资源并对各项任务进行
合理化调度，且附加了各种便于用户操作的工具的软件层次。</li>
</ul>
<p><code>地位</code>：操作系统是硬件之上的第一层<strong>软件</strong>，是对硬件系统的<strong>首次扩充</strong>。OS在计算机系统中占据着特别重要的地位，是计算机中<strong>最重要的系统软件</strong>，是其他系统软件和应用软件<strong>运行的基础</strong>。</p>
<p><code>作用</code>：</p>
<ul>
<li>作为用户与计算机硬件之间的接口</li>
<li>作为计算机系统资源的管理者</li>
<li>实现了对计算机资源的抽象</li>
</ul>
</blockquote>
<h3 id="多道程序设计">多道程序设计</h3>
<p>定义：</p>
<blockquote>
<ul>
<li>多道程序设计技术是指在内存中同时存放若干个作业，使它们
共享系统资源并同时运行的技术。在单处理机环境下，这些作
业仅在宏观上同时运行，而在微观上交替执行。</li>
</ul>
</blockquote>
<p>好处：</p>
<blockquote>
<ul>
<li>可提高CPU的利用率</li>
<li>可提高内存和I/O设备利用率</li>
<li>可增加系统吞吐量。在保持CPU、I/O设备不断忙碌的同时，也必
然会大幅度地提高系统的吞吐量，从而降低作业加工所需的费用。</li>
</ul>
</blockquote>
<h3
id="操作系统类型和各自特点及其适用范围批处理分时实时">操作系统类型和各自特点及其适用范围：批处理、分时、实时</h3>
<h4 id="多道批处理系统">多道批处理系统</h4>
<p>定义：</p>
<blockquote>
<ul>
<li>采用多道程序设计技术的批处理系统被称作多道批处理系统。</li>
</ul>
</blockquote>
<p>特点：</p>
<blockquote>
<ul>
<li>用户提交的作业先放在外存上，并排成一个队列，称为后备队列，由作业调度程序按一定的算法从后备队列中选择若干作业
调入内存，使之共享系统资源，并发运行，形成源源不断的作业流。【外存（后备队列）<span
class="math inline">\(\rightarrow\)</span> 作业调度 <span
class="math inline">\(\rightarrow\)</span>
内存；形成了现代意义的操作系统。】</li>
<li>多道批处理系统中必须配置一组软件，即调度程序，来解决多道
程序对系统资源的共享和争用问题，并对作业进行合理的组织和 调度。</li>
<li>用户无法与自己的作业进行交互的主要原因：作业都先驻留在外存上，即使以后被调入内存，也要经过较长
时间的等待后方能运行，导致用户无法与自己的作业进行交互。</li>
</ul>
</blockquote>
<p>优点：</p>
<blockquote>
<ul>
<li>资源利用率高</li>
<li>系统吞吐量大</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>平均周转时间长</li>
<li>无交互能力：用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的
作业进行交互，修改和调试程序极不方便。</li>
</ul>
</blockquote>
<h4 id="分时系统">分时系统</h4>
<p>目的：</p>
<blockquote>
<ul>
<li>解决批处理系统无法进行人机交互的问题以及让多用户同时使用</li>
</ul>
</blockquote>
<p>特点：多路性；及时性；独立性；交互性【参考ppt】</p>
<blockquote>
<ul>
<li>分时系统采用分时技术，将CPU处理时间进行分割，形成多个特定大
小的时间片段，这些片段被称为时间片。而分时系统中的每个用户在获取CPU控制权后，最长只能执行一个时间片长度，然后就必须让出
CPU，交给其他等待用户使用。</li>
<li>采用时间片轮转的办法，使一台计算机同时
为多个终端用户服务。该系统对每个用户都能保证足够快的响应
时间，并提供交互会话功能。</li>
<li>作业直接进入内存</li>
</ul>
</blockquote>
<h4 id="实时系统">实时系统</h4>
<p>特点：及时性；可靠性</p>
<blockquote>
<ul>
<li>时间是关键参数，即系统应能及时响应外部事件的请求（用户的
请求），在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</li>
<li>实时控制系统：要求计算机能尽快处理测量系统测得的数据，以尽快
实施响应控制</li>
<li>实时控制系统：要求计算机能尽快处理测量系统测得的数据，以尽快
实施响应控制</li>
</ul>
</blockquote>
<p>类型：</p>
<blockquote>
<p><strong>实时任务</strong>类型：</p>
<ul>
<li>硬实时：任务必须在指定截止时间(或之前)开始或完成</li>
<li>软实时：要求不是十分严格，偶尔可以超出时限，对系统正确性和
安全性不会有太大的影响</li>
</ul>
</blockquote>
<blockquote>
<p><strong>实时系统</strong>类型：</p>
<ul>
<li>硬实时系统：系统必须满足应用程序对截止期限的要求，若错过了
截止期限，将导致灾难性后果</li>
<li>软实时系统：系统能够接受偶尔违反时间规定，并且此时不会带来
严重后果</li>
</ul>
</blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/46c705f84d1241abaadcd5e34bace574.png"
alt="实时系统与分时系统比较" />
<figcaption aria-hidden="true">实时系统与分时系统比较</figcaption>
</figure>
<h3 id="操作系统特征">操作系统特征</h3>
<p><strong>并发，共享，虚拟，异步</strong></p>
<blockquote>
<p>其中并发性是操作系统最重要的特征，其它三个特性均基 于并发性而存在</p>
</blockquote>
<p>并发：</p>
<blockquote>
<ul>
<li><strong>并发性：</strong>若在一个<strong>时间段</strong>内发生了一个以上的事件</li>
<li><strong>并行性：</strong>是多个事件在同一时刻点发生</li>
</ul>
<p>在单处理机系统中，每个<strong>特定时刻</strong>只能有<strong>一个</strong>程序在CPU中运行。但一个较长的时间段可以被分为多个小的时间片，这些时间片可以按照一定的原则发放给多个不同的程序，使得在这个时间段内有多个程序得到一定程度的执行，故：程序是具有<strong>并发性</strong>、不具有<strong>并行性</strong>的。</p>
</blockquote>
<p>共享：多个并发执行的程序按照一定的规
则共同使用操作系统所管理的软硬件资源。</p>
<blockquote>
<ul>
<li><p>互斥访问：在<strong>一段时间</strong>内只允许<strong>一个</strong>进程访问的资源，被称为<code>临界资源</code>，<code>临界资源</code>的访问是互斥访问方式；直到使用该资源的进程访问完并释放该资源后，才允许另一
个进程访问该资源。</p></li>
<li><p>同时访问：指的是在一段时间内允许<strong>多个</strong>进程并发访问。</p></li>
</ul>
</blockquote>
<p>虚拟：对于计算机系统中的物理设备，通过某种技术，将一个
物理实体映射为多个具有对应物的功能的逻辑设备。【映射通常是
利用时分复用技术或空分复用技术的方式实现】</p>
<blockquote>
<ul>
<li>虚拟性的操作系统可以将一个设备映射为多个，
将一个设备的能力均分到不同的逻辑设备上，以便多用户共享资源。</li>
<li>虚拟性能够极大地提高资源利用率。</li>
</ul>
</blockquote>
<p>异步：操作系统中的各个程序的推进次序无法预知。</p>
<blockquote>
<ul>
<li>是由现代操作系统的<strong>并发性</strong>引起的。</li>
</ul>
</blockquote>
<h3 id="cpu-工作态系统态管态和用户态目态及其转换">CPU
工作态【系统态（管态）和用户态（目态）】及其转换</h3>
<p>两类程序：<strong>系统程序</strong>，<strong>应用程序</strong>。</p>
<p>CPU的两种工作状态（防止OS遭应用程序破坏）：系统态，用户态</p>
<blockquote>
<ul>
<li>系统态（内核态、核心态、管态、特权态）：OS内核代码运行在系统态</li>
<li>用户态：应用程序和非内核部分的OS程序代码运行在用户态</li>
</ul>
</blockquote>
<p>OS将CPU指令集分为：特权指令，非特权指令。</p>
<blockquote>
<p><code>特权指令：</code></p>
<ul>
<li>只能提供给操作系统的核心程序使用，运行在系统态 。</li>
<li>具有特殊权限，对内存空间的访问基本不受限制，不仅能访问用户空间，
也能访问系统空间。</li>
<li>特权指令不允许用户程序直接使用。</li>
</ul>
<p><code>非特权指令：</code></p>
<ul>
<li>用户程序可以执行，运行在用户态 。</li>
<li>对内存的访问局限于用户空间，不能对系统中的硬件直接进行访问。
这种限制是由硬件实现的。</li>
</ul>
</blockquote>
<p>区分<strong>系统态</strong>和<strong>用户态</strong>：程序状态字。</p>
<blockquote>
<ul>
<li>用来控制指令执行顺序并保留和指示与程序有关的系统状态，主要作用是实现
程序状态的保护和恢复。</li>
<li>区分CPU处于哪种工作状态，只需要访问CPU的<strong>PSW寄存器</strong>。</li>
</ul>
</blockquote>
<p><code>系统态</code>与<code>用户态</code>的转换：</p>
<blockquote>
<p><code>用户态</code><span
class="math inline">\(\rightarrow\)</span><code>系统态</code>：中断</p>
<blockquote>
<ul>
<li>用户程序使用系统调用来请求操作系统服务</li>
<li>发生硬件中断</li>
<li>用户程序出错或者出现非法特权指令</li>
</ul>
</blockquote>
<p><code>系统态</code><span
class="math inline">\(\rightarrow\)</span><code>用户态</code>：<strong>修改</strong>程序状态字<span
class="math inline">\(PSW\)</span>中CPU的状态位。（属于特权指令）</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/1dcbaff155f3468fb36493bffdd3c31c.png"
alt="在这里插入图片描述" />
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
</blockquote>
<h2 id="第二章进程管理">第二章：进程管理</h2>
<h3 id="进程定义引入原因特征分类">进程定义、引入原因、特征、分类</h3>
<p>定义：可并发执行且具有独立功能的程序在一个数
据集合上的运行过程（程序的一次执行），它是操作系统进行资源分配和调度的基本单位”。</p>
<blockquote>
<ul>
<li><strong>引入原因</strong>：使程序能够并发执行，并且能对并发的程序加以描述和控制
而引入的；</li>
<li>进程是一个程序运行的动态过程，该程序必须具有并发运行的程序结构；</li>
<li>为了<strong>管理和控制进程</strong>要为每个进程配置一个专门的<strong>数据结构</strong>，称为进程控制块（PCB）；</li>
<li><strong>进程</strong>包括：<strong>程序段</strong>，<strong>数据段</strong>，<strong>进程控制块</strong>；</li>
</ul>
</blockquote>
<p>特征：</p>
<blockquote>
<ul>
<li><code>结构性</code>：进程由程序段、数据段和PCB构成。并且进程和PCB是一一对应的。</li>
<li><code>动态性</code>：进程是程序的执行过程，具有<strong>生命周期</strong>：由创建而产生，由调度而
执行，由撤销而消亡。</li>
<li><code>并发性</code>：多个进程存在于内存中，且能在一段时间内同时运行。</li>
<li><code>独立性</code>：进程是能独立运行、独立获得资源和独立接受调度的基本单位。</li>
<li><code>异步性</code>：进程是按异步方式运行的，即按各自独立的、不可预知的速度向前
推进。</li>
</ul>
</blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/e7808e8c66844c0dbad42a7dbf2dfe34.png"
alt="进程与程序的区别" />
<figcaption aria-hidden="true">进程与程序的区别</figcaption>
</figure>
<h3 id="pcb">PCB</h3>
<p>定义：为便于管理和控制进程，操作系统为每个进程定义了一个专门的数据结构用于表征进程实体，我们称之为进程信息表，通常又被称为进程控制块（PCB）。</p>
<blockquote>
<ul>
<li>用于<strong>记录</strong>操作系统所需的、用于<strong>描述进程的当前情况</strong>以及<strong>管理进程</strong>
运行的全部信息。</li>
</ul>
</blockquote>
<p>作用：</p>
<blockquote>
<ul>
<li>作为独立运行基本单位的<strong>标志</strong></li>
<li><strong>能实现</strong>间断性运行方式</li>
<li><strong>提供</strong>进程管理所需要的<strong>信息</strong></li>
<li><strong>提供</strong>进程<strong>调度</strong>所需要的信息</li>
<li><strong>实现</strong>与其它进程的<strong>同步</strong>与<strong>通信</strong></li>
</ul>
</blockquote>
<p>PCB的组织方式：<strong>线性</strong>方式，<strong>链接</strong>方式，<strong>索引</strong>方式</p>
<h3 id="进程基本状态及其转换">进程基本状态及其转换</h3>
<p>三种最基本状态：执行，就绪，阻塞</p>
<blockquote>
<ul>
<li><code>执行</code>：进程已获得运行所必需的资源，正在处理机上执行
。</li>
<li><code>就绪</code>：进程已处于准备好运行的状态，即进程已获得
除CPU以外的运行所必需 的资源，只要获得CPU的使用权限，便可立即执行。</li>
<li><code>阻塞</code>：进程正等待着某一事件的发生而暂时停止执行的状态。（这时，即使给它
CPU控制权，它也无法执行）</li>
</ul>
<p>状态转换：</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/12216f07bf4842909c0f557f85d827c9.png"
alt="进程三种基本状态的转换" />
<figcaption aria-hidden="true">进程三种基本状态的转换</figcaption>
</figure>
</blockquote>
<p>为了满足进程控制块对数据及操作的完整性要求，又引入了<code>创建状态</code>和<code>终止状态</code>。</p>
<blockquote>
<ul>
<li><code>创建状态</code>：进程所需的资源尚不能得到满足，此时创建工作尚未完成，进程不能被调度运行，此时称为创建状态。</li>
<li><code>终止状态</code>：进程到达自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其它
有终止权的进程所终结。</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/622ecb05e3d9402ea7cb76fa0ed11359.png"
alt="五种基本状态的转换" />
<figcaption aria-hidden="true">五种基本状态的转换</figcaption>
</figure>
</blockquote>
<p>引入<code>挂起操作</code>的系统：如果进程正在执行，它将暂停执行；
若进程原本处于就绪状态，则该进程暂时不接受调度。（与之对应的是<code>激活操作</code>）</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/275b56f14d1345a2a9a2fa3de1d9d311.png"
alt="具有挂起操作的状态转换" />
<figcaption aria-hidden="true">具有挂起操作的状态转换</figcaption>
</figure>
<h3
id="进程控制原语进程创建进程阻塞进程唤醒">进程控制：原语、进程创建、进程阻塞、进程唤醒</h3>
<p><code>原语</code>：由若干条指令组成，完成一定的功能。所有动作<strong>不可分割</strong>，要么全做，要么全不做。</p>
<p><code>进程创建</code>：允许一个<strong>进程创建另一个进程</strong>，通常把创建进程的进程称为<strong>父进程</strong>，而把被创建的进程称为<strong>子进程</strong>。子进程可继续创建更多的<strong>孙进程</strong>，由此便形成了一个进程的层次结构。</p>
<blockquote>
<ul>
<li><strong>子进程</strong>可以继承<strong>父进程</strong>所拥有的全部资源</li>
<li>当子进程被撤销时，应将从父进程那里 获得的资源归还给父进程</li>
<li>撤销<strong>父进程</strong>时，也必须同时<strong>撤销</strong>其所有的<strong>子进程</strong></li>
</ul>
</blockquote>
<p>引起<code>进程阻塞</code>or<code>唤醒</code>的事件：</p>
<blockquote>
<p>向系统请求共享资源</p>
<ul>
<li>例如申请打印机</li>
</ul>
<p>等待某种操作的完成</p>
<ul>
<li>例如I/O操作</li>
</ul>
<p>等待新数据的到达</p>
<ul>
<li>等待新数据的到达</li>
</ul>
<p>等待新任务的到达</p>
<ul>
<li>例如网络环境中的发送进程，若已有数据包已全部发送完成，发送进程
将自己阻塞，仅当有新的数据包到达时，才将其唤醒</li>
</ul>
</blockquote>
<p>进程的<strong>阻塞</strong>是进程自身的一种<strong>主动行为</strong>。</p>
<p>阻塞进程<strong>不能唤醒</strong>自己。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/b347cd00dc70404b94a9e5857a754890.png"
alt="阻塞，唤醒流程图" />
<figcaption aria-hidden="true">阻塞，唤醒流程图</figcaption>
</figure>
<h3 id="进程同步全章节">进程同步全章节</h3>
<p><code>进程同步</code>：<strong>直接</strong>相互制约关系，这种制约来源<strong>进程间的合作</strong>。</p>
<blockquote>
<ul>
<li>为了完成某项任务的两个或多个进程，这些进程因为需要在某些位置上
协调它们的工作次序而等待、传递信息所产生的制约关系。</li>
<li>进程同步的主要任务就是使并发执行的各进程之间能有效地共享资源和相互
合作，从而在执行时间、次序上相互制约，按照一定的协议协调执行，使程
序的执行具有可再现性。</li>
</ul>
</blockquote>
<p><code>进程互斥</code>：<strong>间接</strong>相互制约关系，当<strong>多个进程</strong>需要使用相同的临界资源时，<strong>操作系统</strong>通常将临界资源分配给<strong>首先提出使用申请</strong>的进程。</p>
<blockquote>
<ul>
<li>没有获得此资源的进程必须等待；</li>
<li>这种对共享资源的排它性使用所造成的进
程间的间接制约关系称为进程互斥；</li>
<li>互斥是一种<strong>特殊</strong>的同步方式；</li>
</ul>
</blockquote>
<p><code>临界区</code>：为保证<strong>多个进程</strong>对<strong>临界资源</strong>进行正确的<strong>互斥访问</strong>，人们把<strong>每个进程中访问</strong>临界资源的那段<strong>代码</strong>使用特殊手段管理，这段代码被称为<strong>临界区</strong>。</p>
<blockquote>
<ul>
<li>能保证诸进程<strong>互斥地进入</strong>自己的<strong>临界区</strong>，即可实现对<strong>临界资源</strong>的<strong>互斥访问</strong>；</li>
<li>临界区是由属于<strong>不同并发进程</strong>的程序段<strong>共享</strong>公用数据或公用数据变量而引起的。<strong>临界区</strong>不可能用增加硬件的方法来解决。因此，临界区也可以被称为<strong>访问公用数据的那段程序</strong>；</li>
<li>进程在进入<strong>临界区</strong>之前，首先要对<strong>临界资源的使用情况进行查询</strong>：</li>
</ul>
<blockquote>
<ul>
<li>临界资源处于空闲状态：该进程可以进入临界区，同时把
临界资源的状态设置为正在使用状态；</li>
<li>临界资源正在被使用，那么该进程不能进入临界区；</li>
</ul>
</blockquote>
<ul>
<li><strong>进入区</strong>：位于临界区前面的一段用于检查临界区使用状态的代码被称为进入区；</li>
<li><strong>退出区</strong>：完成对临界区的访问之后，要把临界区访问标志恢复为未被访问标志，完成该任务的代码段被称为退出区；</li>
<li><strong>剩余区</strong>：除了进入区、临界区和退出区之外
的部分被称为剩余区；</li>
</ul>
<p><code>进入区</code>，<code>临界区</code>，<code>退出区</code>，<code>剩余区</code>都是：<strong>代码</strong>！</p>
</blockquote>
<p>实现<strong>互斥</strong>遵循规则：</p>
<blockquote>
<ul>
<li>空闲让进：当无进程处于临界区时，允许进程进入临界区，并且只能在临界区运行<strong>有限的时间</strong>；</li>
<li>忙则等待：当有一个进程在临界区时，其它欲进入临界区的进程必须等待，以保证进程互斥地
访问临界资源；</li>
<li>有限等待：对要求访问临界资源的进程，应保证进程能在<strong>有限时间内</strong>进入临界区，以免陷入
“饥饿”状态；</li>
<li>让权等待：当进程不能进入临界区时，应<strong>立即放弃占用CPU</strong>，以使其它进程有机会得到CPU的
使用权，以免陷入“饥饿”状态；</li>
</ul>
</blockquote>
<blockquote>
<p>Q：如何实现对临界资源的<strong>互斥</strong>访问？</p>
<p>A1：检测是否空闲可用：可用就用；不可用就等待</p>
<p>A2：对临界资源<strong>“加锁
”</strong>：使用者申请到资源先给资源“上锁”； 用完给资源“开锁”
还给系统</p>
</blockquote>
<p>实现临界区互斥的方法：</p>
<blockquote>
<p><strong>软件方法1</strong>：单标志法（违背“空闲让进”）。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/ed53f45ac6d34ec3a14122c8876b7834.png"
alt="单标志法" />
<figcaption aria-hidden="true">单标志法</figcaption>
</figure>
<p><strong>软件方法2</strong>：双标志法先检查（违背“忙则等待”）。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/1af9c1d34347480788a2eb327b99463b.png"
alt="双标志法先检查" />
<figcaption aria-hidden="true">双标志法先检查</figcaption>
</figure>
<p><strong>软件方法3</strong>：双标志法后检查（会导致“饥饿”）。</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/851652336849448bbe99463e45c12838.png"
alt="双标志法后检查" />
<figcaption aria-hidden="true">双标志法后检查</figcaption>
</figure>
<p><strong>软件方法4</strong>：皮特森算法</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/2b5ffce00e6a4bc9bb3e64ce2c5adc7e.png"
alt="皮特森算法" />
<figcaption aria-hidden="true">皮特森算法</figcaption>
</figure>
<p><strong>锁机制</strong>：临界资源（临界区）互斥访问的重要方式之一</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/900d720877044ca1b20b9202d862663e.png"
alt="锁机制" />
<figcaption aria-hidden="true">锁机制</figcaption>
</figure>
</blockquote>
<blockquote>
<p><strong>硬件方法1</strong>：中断屏蔽方法</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/90a949a8689a497e8b409caca7b6aac3.png"
alt="中断屏蔽法" />
<figcaption aria-hidden="true">中断屏蔽法</figcaption>
</figure>
<p><strong>硬件方法2</strong>：硬件指令方法</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/4fd27205ef3d4e49b3e8a9aed782568b.png"
alt="硬件指令方法" />
<figcaption aria-hidden="true">硬件指令方法</figcaption>
</figure>
<blockquote>
<p><span class="math inline">\(TestAndSet\)</span> 和<span
class="math inline">\(Swap\)</span>指令，不是软件实现的，是由硬件逻辑直接实现的！</p>
</blockquote>
</blockquote>
<p>信号量机制：</p>
<blockquote>
<p><strong>整形信号量</strong>：</p>
<blockquote>
<ul>
<li>信号量S是个<strong>整型变量</strong>，通常被<strong>初始化</strong>为<strong>相应资源的初始数量</strong>；</li>
<li>对<strong>信号量S</strong>只能通过<span
class="math inline">\(wait\)</span>和<span
class="math inline">\(signal\)</span>这两个标准的<strong>原子操作</strong>来访问
，这就保证了当一个进程在修改某信号量时，没有其它进程同时对它进行修改；</li>
<li><span class="math inline">\(wait\)</span> (<span
class="math inline">\(P\)</span>);<span
class="math inline">\(signal\)</span>(<span
class="math inline">\(V\)</span>) -- <span
class="math inline">\(P\)</span>,<span
class="math inline">\(V\)</span>操作（荷兰语）</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/1b59b2348b8f4bc69c266f17e84e9e21.png"
alt="整形信号量-PV操作" />
<figcaption aria-hidden="true">整形信号量-PV操作</figcaption>
</figure>
</blockquote>
<p><strong>记录型信号量</strong>：</p>
<blockquote>
<ul>
<li>除了需要一个用于<strong>代表资源数目的整型变量</strong><span
class="math inline">\(value\)</span>之外，又增加一个<strong>进程链表</strong><span
class="math inline">\(L\)</span>（<strong>对应与信号量相关的等待队列</strong>），用于链接与之相关的所有<strong>等待进程</strong>，这两者共同构成了记录型信号量；</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/24568b7d39e0445984417eae4066356f.png"
alt="记录型信号量PV操作" />
<figcaption aria-hidden="true">记录型信号量PV操作</figcaption>
</figure>
<ul>
<li><span
class="math inline">\(block(S.L)\)</span>操作用于<strong>阻塞</strong>调用它的进程，<span
class="math inline">\(wakeup(S.L)\)</span>操作用于<strong>唤醒</strong>链表<span
class="math inline">\(L\)</span>的链首阻塞进程。
这两个操作都是<strong>原语操作</strong>，以系统调用的形式由操作系统提供；</li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43237362/article/details/104706227">记录型信号量详细逻辑-
author"Orange#"</a></p>
</blockquote>
<p><strong><span
class="math inline">\(AND\)</span>型信号量</strong>：只满足了“需要多种资源，且数量为1”的情况（参考下图代码）</p>
<blockquote>
<ul>
<li><p>将进程在整个运行过程中需要的所有资源，<strong>一次性全部地分配</strong>给进程，等到进程使用完毕后再一起释放；</p></li>
<li><p>只要还有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给它；采取<strong>原子操作</strong>的方式即：<strong>要么全部分配给进程，要么一个也不分配</strong>；</p></li>
<li><p>可避免<strong>死锁</strong>发生（由死锁理论得，按下不表）；</p></li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/c61d5d96979b4deaa6d814e899bf967a.png"
alt="AND型信号量" />
<figcaption aria-hidden="true">AND型信号量</figcaption>
</figure>
</blockquote>
</blockquote>
<p>信号量集：为了解决<span
class="math inline">\(AND\)</span>型信号量的问题而引入。</p>
<blockquote>
<ul>
<li>在<span
class="math inline">\(AND\)</span>型信号量的基础上进行扩充，在一<strong>次原语操作中完成所有的资源申请</strong>；进程对信号量<span
class="math inline">\(S_i\)</span>的测试值为<span
class="math inline">\(t_i\)</span>，要求<span
class="math inline">\(S_i&gt;=t_i\)</span>，即当资源数量低于<span
class="math inline">\(t_i\)</span>时，便不予分配；当<strong>允许分配</strong>时，如果进程对该资源的<strong>需求值</strong>为<span
class="math inline">\(d_i\)</span>（即申请的资源数量），进行<span
class="math inline">\(S_i=S_i-d_i\)</span>操作；</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/b74cd08078d54fa2840893843b9ef1a9.png"
alt="信号量集" />
<figcaption aria-hidden="true">信号量集</figcaption>
</figure>
<p>一般信号量集的几种特殊情况：</p>
<blockquote>
<ul>
<li><span class="math inline">\(Swait(S, d,
d)\)</span>：此时在信号量集中<strong>只有一个信号量</strong>，但它允许<strong>每次申请<span
class="math inline">\(d\)</span>个资源</strong>；当现有资源少于<span
class="math inline">\(d\)</span>个时，便不予分配；</li>
<li><span class="math inline">\(Swait(S, 1,
1)\)</span>：此时的信号量集已<strong>退化为一般</strong>的<strong>记录型信号量</strong>；</li>
<li><span class="math inline">\(Swait(S, 1,
0)\)</span>：这是一种很特殊且很有用的信号量。当<span
class="math inline">\(S≥1\)</span>时，允许多个进程进入某特定区； 当<span
class="math inline">\(S\)</span>变为<span
class="math inline">\(0\)</span>后，将<strong>阻止任何进程</strong>进入该特定区。换言之，其相当于一个可控
的<strong>软开关</strong>；</li>
</ul>
</blockquote>
</blockquote>
<p>信号量的使用方法：</p>
<blockquote>
<ul>
<li>使用<strong>信号量</strong>和<strong><span
class="math inline">\(P、V\)</span></strong>操作，可以方便地解决并发进程的<strong>互斥问题</strong>，不
会出现些软硬件方法所存在的问题；</li>
<li>设<strong>信号量</strong><span
class="math inline">\(mutex\)</span>是用于多个进程互斥的公共信号量，只要把<strong>临界区</strong>置于<span
class="math inline">\(P(mutex)\)</span>和<span
class="math inline">\(V(mutex)\)</span>之间，即可实现进程间的互斥；</li>
<li><span
class="math inline">\(P,V\)</span><strong>成对</strong>出现！先申请在进入临界区，不退出不让权；</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/add0efca3b1d472d9abdb9ddfb05736c.png"
alt="互斥进程组织结构模型" />
<figcaption aria-hidden="true">互斥进程组织结构模型</figcaption>
</figure>
<p>利用信号量实现<strong>进程互斥</strong>：</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/eb4d78244eba41d1925e92491e98245f.png"
alt="实现进程互斥" />
<figcaption aria-hidden="true">实现进程互斥</figcaption>
</figure>
<p>利用信号量实现<strong>合作进程同步</strong>：（下面大量例题图片）</p>
</blockquote>
<h3 id="经典同步实现算法">经典同步实现算法</h3>
<h4 id="生产者-消费者问题">生产者-消费者问题</h4>
<p><code>消费者</code>：<strong>使用</strong>某一类资源的进程</p>
<p><code>生产者</code>：<strong>释放</strong>同类资源的进程</p>
<blockquote>
<p>【问题描述】：</p>
<blockquote>
<p>一批生产者生产特定的产品，并将其放入具有<span
class="math inline">\(n\)</span>个缓冲区的环状缓冲池。生产者一次只能放入一个产品，若当前使用的是<span
class="math inline">\(n-1\)</span>号缓冲区，下一个可用的就是<span
class="math inline">\(0\)</span>号缓冲区。消费者从缓冲池中取出产品去消费，一次只能取出一个
产品。生产者和消费者、消费者之间、生产者之间均对缓冲池<strong>互斥访问</strong>。</p>
<ul>
<li>使用固定的有限数目的 n个缓冲区来进行任意数目消
息的传递，因此也被称为<strong>有界缓冲区问题</strong>。</li>
</ul>
</blockquote>
<p>【规则】：</p>
<blockquote>
<p>生产者一次只能放入一个产品，消费者一次只能取出一个产品。生产者和消费者、消费者之间、生产者之间均对缓冲池<strong>互斥访问</strong>。</p>
</blockquote>
<p>【问题分析】：</p>
<blockquote>
<ul>
<li>显然，缓冲池是<strong>临界资源</strong>，需要为其设置一个<strong>互斥信号量</strong><span
class="math inline">\(mutex\)</span>；</li>
<li>为能使用正确的空、满缓冲区，需设置两个资源信号量<span
class="math inline">\(empty\)</span>和<span
class="math inline">\(full\)</span>，分别指示空 、满缓冲区的个数；<span
class="math inline">\(empty\)</span> 和<span
class="math inline">\(full\)</span>的<strong>初值</strong>分别是<span
class="math inline">\(n\)</span>和<span
class="math inline">\(0\)</span>；</li>
<li>还需要使用两个特殊<strong>指针</strong><span
class="math inline">\(in\)</span>和<span
class="math inline">\(out\)</span>，分别指向生产者使用的空缓冲区和消费者使用的满缓冲区。每当<span
class="math inline">\(in\)</span> 或<span
class="math inline">\(out\)</span>当前指向的缓冲区被生产者或消费者使用后，均需要<strong>后移</strong>一个缓冲区；</li>
</ul>
</blockquote>
<p>【伪代码】：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/c74977be889c4b05830e374012c94d09.png"
alt="生产者-消费者问题1" />
<figcaption aria-hidden="true">生产者-消费者问题1</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/7c429690b37f4ad8badd90c8f8942f5c.png"
alt="生产者消费者问题2" />
<figcaption aria-hidden="true">生产者消费者问题2</figcaption>
</figure>
</blockquote>
<p>【小结】：</p>
<blockquote>
<ul>
<li>当程序中出现多个<span
class="math inline">\(P\)</span>操作时<strong>顺序</strong>不能颠倒：应<strong>先对资源信号量</strong>进行<span
class="math inline">\(P\)</span>操作，<strong>再对互斥信号量</strong>进行<span
class="math inline">\(P\)</span>操作；</li>
<li>用于<strong>实现互斥</strong>的信号量的<span class="math inline">\(P
、 V\)</span>操作必须<strong>成对出现</strong>；</li>
<li>合作进程之间，通过<strong>资源信号量</strong>传递信息：生产者在<strong>产生资源后</strong>进行<span
class="math inline">\(V\)</span>操作发送资源已存在信息；消费者在<strong>使用资源前</strong>进行<span
class="math inline">\(P\)</span>操作申请并检查资源是否可用；</li>
</ul>
</blockquote>
</blockquote>
<h4 id="读者-写者问题">读者-写者问题</h4>
<p><code>读者</code>进程：可以和同类的其它进程一起共享资源，且不会对资源进行改写，只获取资源的副本，它们的行为与去图书馆读书的读者很相似；</p>
<p><code>写者</code>进程：能够对资源进行<strong>改写</strong>，且在使用资源的时候<strong>排斥</strong>其它<strong>任何类型</strong>的进程使用该资源，这样的行为又与书籍的作者类似；</p>
<blockquote>
<p>【问题描述】：</p>
<blockquote>
<p>该问题假设<strong>一种资源在两种截然不同的进程间共享</strong>。</p>
<p>经常用来描述一组进程共享一个文件时，多个<strong>只读权限</strong>的进程可以同时共享该文件，一旦有进程对文件<strong>进行改写</strong>时，其它<strong>任何进程</strong>（无论是读者还是写者）均<strong>不可共享</strong>该文件。</p>
</blockquote>
<p>【方案】：</p>
<blockquote>
<p><strong>读者优先</strong>：</p>
<p><strong>只要</strong>有一个<strong>读者持有资源</strong>，后继到达的读者可以被允许立即进入临界区，而后继到达的<strong>写者将被当前的读者排斥</strong>而无法进入临界区，只能阻塞自身。</p>
<p><strong>只有</strong>第一个到达的读者需要与写者竞争共享资源，只要读者获得共享资源后，在资源<strong>没有被释放之前</strong>，后继的<strong>读者</strong>都可以<strong>直接进入临界区</strong>访问。</p>
</blockquote>
<blockquote>
<p><strong>写者优先</strong>：</p>
<p>当一个写者请求访问共享资源时，任一随后到达的读者进程必须等待。</p>
<p>当第一个写者离开临界区后，由于写者的优先级高于读者，则第二个写者将进入
临界区，读者将会等待。只有所有的写者都离开临界区后，读者才可进入自身临
界区。</p>
</blockquote>
<blockquote>
<p><strong>读写公平</strong>：</p>
<p>当有读者持有资源时，如果有写进程请求访问，这时要禁止后继到达的读者进入临界区。后继到达的读者和写者将和之前到达的写者一起被阻塞，排队等候，这时写者进程和读者进程具有<strong>同样的优先级</strong>。</p>
</blockquote>
<p>【读者优先伪代码】：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/677d8c11410e4745854af3354d008703.png"
alt="读者优先1" />
<figcaption aria-hidden="true">读者优先1</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/0a9b3a05e1f24d959432c3b873ec7666.png"
alt="读者优先2" />
<figcaption aria-hidden="true">读者优先2</figcaption>
</figure>
<p>【读者优先缺点】：</p>
<ul>
<li>如果一直有读者，有可能导致写者进程“饿死”；</li>
<li>写者不能更新文件，读者操作可能是基于陈旧的数据；</li>
</ul>
</blockquote>
<p>【写者优先】：</p>
<blockquote>
<p>有“写者”存在时，可能有两个阻塞队列：</p>
<ul>
<li>随后到达的<strong>“写者”</strong>队列；</li>
<li>随后到达的<strong>“读者”</strong>队列</li>
</ul>
</blockquote>
<p>【读写公平】：</p>
<blockquote>
<p>有<strong>“写者”</strong>存在时，才存在<strong>“读写公平”</strong>队列；</p>
</blockquote>
</blockquote>
<h4 id="哲学家进餐问题">哲学家进餐问题</h4>
<blockquote>
<p>【问题描述】：</p>
<blockquote>
<p>五个哲学家一生都在思考和进餐中度过，他们围坐在一个<strong>圆桌</strong>周围，每人面前放了一份美味的餐点，两份相邻的餐盘中间都放了<strong>一根</strong>筷子，哲学家需要把自己左右两侧的两个筷子分别拿起才能进餐。哲学家的行为模式就是平时思考，饿了就分别拿起两侧的筷子，若两次都能成功，即获得了两根筷子时，该哲学家就可以进餐了。当他吃饱后，为了不让其他人挨饿，需要马上将两根筷子分别放下，注意，这里并没有对拿起和放下筷子的次序做强制规定。</p>
</blockquote>
<p>【问题分析】：</p>
<blockquote>
<ul>
<li><strong>筷子是临界资源</strong>，同一根筷子同一时段只能有一个哲学家可以拿到；</li>
<li>五只筷子，也就是五个临界资源；</li>
<li>一共有五个哲学家，也就是五个进程；</li>
<li>一个哲学家想要进餐，必须要同时获得左边和右边的筷子，即同时使用临近的两个临界资源（进入两个临界区），才可以进餐；</li>
</ul>
</blockquote>
<p>【最直接解法】：强制每个哲学家都先拿起左边的筷子，成功后再去拿起右边的筷子。</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/adb7bc6a001947cd86427b52fdae9ee6.png"
alt="直接解法" />
<figcaption aria-hidden="true">直接解法</figcaption>
</figure>
<p><strong>缺点</strong>：若五个哲学家同时拿起左筷子，会产生死锁导致严重的“饥饿”现象。</p>
</blockquote>
<p>【避免死锁方法一】：</p>
<blockquote>
<p>方法描述：至多只允许有四位哲学家同时去拿左边的筷子，<strong>可以设置一个信号量限制同时进餐
的哲学家数量。</strong></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/77a24a1d76c54c91aad99c4499d3a558.png"
alt="方法一" />
<figcaption aria-hidden="true">方法一</figcaption>
</figure>
<ul>
<li>可以实现互斥和同步</li>
<li>缺点：并发度可能达不到最高</li>
</ul>
</blockquote>
<p>【避免死锁方法二】：</p>
<blockquote>
<p>【方法描述】：仅当哲学家左、右两支筷子可用时，才允许他
拿起筷子，需要先<strong>检测两支筷子是否可用</strong>；利用<strong>信号量的保护机制</strong>对取左右筷子操作进行保护，实现互斥和同步。</p>
<p>【互斥信号量实现-伪代码】：</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/571ba0811f5d46a89023e4e4d9d80001.png"
alt="互斥信号量伪代码" />
<figcaption aria-hidden="true">互斥信号量伪代码</figcaption>
</figure>
<p>【<span
class="math inline">\(AND\)</span>型信号量实现-伪代码】：简洁，易懂！</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/19241ea5efd546f88ace9443028dd573.png"
alt="and型信号量" />
<figcaption aria-hidden="true">and型信号量</figcaption>
</figure>
</blockquote>
<p>【避免死锁方法三】：</p>
<blockquote>
<p>【方法描述】：规定奇数号哲学家先拿他左边的筷子，然后再去拿右边的筷子；
而偶数号哲学家则相反；需要在代码中<strong>添加个判断，来决定获取左、右筷子的顺序</strong>。</p>
<p>【伪代码】：</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/eec1fea4e8f64a62a968bf5fd7a2aff5.png"
alt="伪代码" />
<figcaption aria-hidden="true">伪代码</figcaption>
</figure>
</blockquote>
</blockquote>
<p>例题：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/4980e9108ae34c66916ec7ef41326aec.png"
alt="博物馆问题" />
<figcaption aria-hidden="true">博物馆问题</figcaption>
</figure>
</blockquote>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/c01593badaaf4f979d947b7224c71c7c.png"
alt="生消例题1" />
<figcaption aria-hidden="true">生消例题1</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/afb30ded4a5c41aea8036716ca12c646.png"
alt="生消例题2" />
<figcaption aria-hidden="true">生消例题2</figcaption>
</figure>
</blockquote>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/8dd7ab2a2c114436b8883eb26b5d0593.png"
alt="哲学家例题" />
<figcaption aria-hidden="true">哲学家例题</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/f5759f627e7c4c16932e56657011af04.png"
alt="哲学家例题2" />
<figcaption aria-hidden="true">哲学家例题2</figcaption>
</figure>
</blockquote>
<h3
id="进程通信共享存储区消息缓冲信箱管道">进程通信：共享存储区、消息缓冲、信箱、管道</h3>
<p>进程通信<code>定义</code>：进程间的信息交换。</p>
<blockquote>
<p>根据进程通信方式的特点，可以分为：</p>
<ul>
<li>低级进程通信：效率相对较低；通信过程对用户<strong>不隐蔽</strong>，要由程序员去实现；</li>
<li>高级进程通信：用户可<strong>直接利用</strong>操作系统所提供的一组<strong>通信原语</strong>，高效地传送<strong>大量数据</strong>的一种通信方式；使用方便；效率高；</li>
</ul>
<p><strong>高级进程通信</strong>对用户是透明的；程序员只需要简单<strong>调用</strong>操作系统提供的<strong>通信原语</strong>就能方便地实现进程间的通信，使通信程序编制的复杂性大大
降低。</p>
</blockquote>
<p><code>高级通信机制分为</code>：共享存储系统；消息传递系统；管道(Pipe)通信系统；客户机-服务器系统；</p>
<p><strong>共享存储器系统</strong>：相互通信的进程通过<strong>共享</strong>某些<strong>数据结构</strong>或<strong>共享存储区</strong>实现进程之间的通信。</p>
<blockquote>
<p>细分为两种方式：</p>
<blockquote>
<p>基于<strong>共享数据结构</strong>的通信方式：</p>
<p>操作系统只提供<strong>共享存储器</strong>，对<strong>共享的公共数据结构</strong>的定义及进程间的同步
处理都要由程序员完成，这种方式是<strong>低效</strong>的，只能传递相对少量的数据；</p>
</blockquote>
<blockquote>
<p>基于<strong>共享存储区</strong>的通信方式：</p>
<p>操作系统<strong>将存储器中的一个子空间用作共享存储区</strong>，各进程都可以对该存储
区进行读写操作，每个进程都可以读到其它合作进程放入该区的数据；这种
方式能够传输的数据量取决于<strong>共享存储区的大小</strong>，可以实现大量数据的传输；</p>
</blockquote>
</blockquote>
<p><strong>管道通信系统</strong>：是一种以<strong>文件系统</strong>为基础实现的适用于在进程
之间实现<strong>大量数据传送</strong>的通信方式。</p>
<blockquote>
<ul>
<li>所谓管道(<span
class="math inline">\(pipeline\)</span>)是指连接一个<strong>接收</strong>(读)进程和一个<strong>发送</strong>(写)进程以实现它们之间通信的一个特殊的<strong>共享文件</strong>，又称为<span
class="math inline">\(pipe\)</span><strong>文件</strong>、<strong>管线</strong>；</li>
<li><strong>发送进程</strong>负责向管道写入数据，<strong>接收进程</strong>负责从管道读取数据；</li>
<li>管道通信方式首创于<span
class="math inline">\(UNIX\)</span>系统；</li>
<li><strong>管道通信</strong>机制允许进程按<strong>先进先出</strong>的方式传输数据，同时也能保证进程同步操作；</li>
</ul>
<p><strong>管道机制</strong>必须提供以下三方面的协调能力：</p>
<blockquote>
<ol type="1">
<li><strong>互斥</strong>：即当一个进程正在对pipe执行读/写操作时，其它(另一)进程必须等待；</li>
<li><strong>同步</strong>：指当写(输入)进程把一定数量的数据写入pipe，便去<strong>睡眠等待</strong>，
直到读(输出)进程<strong>取走数据后再把它唤醒</strong>。当读进程读一空pipe时，也应<strong>睡眠等待</strong>，直至写进程将数据<strong>写入管道后才将之唤醒</strong>；</li>
<li><strong>确定对方是否存在</strong>：只有确定了对方已存在时才能进行通信；</li>
</ol>
</blockquote>
</blockquote>
<p><strong>消息传递系统</strong>：以格式化的<strong>消息</strong> (<span
class="math inline">\(message\)</span>)为单位，将通信的数据<strong>封装</strong>在消息中，并利用操作系统提供的一组通信命令(<span
class="math inline">\(send\)</span>原语和<span
class="math inline">\(receive\)</span>原语)，在进程间进行消息传递，完成进程间的数据交换；</p>
<blockquote>
<ul>
<li>消息传递机制可以实现<strong>不同主机间多个CPU上进程的通信</strong>；</li>
</ul>
<p>据<strong>实现方式</strong>分为两类：直接通信，间接（信箱）通信；</p>
<blockquote>
<ol type="1">
<li><strong>直接通信</strong>：<strong>发送进程</strong>利用操作系统所提供的<span
class="math inline">\(send\)</span>原语，<strong>直接</strong>把消息发送给目标进程；</li>
<li><strong>间接（信箱）通信</strong>：<strong>发送</strong>和<strong>接收进程</strong>都通过<strong>共享中间实体</strong>（<strong>信箱</strong>）的方式进行消息的发送和接收；</li>
</ol>
</blockquote>
<blockquote>
<p><strong>直接通信：</strong>常用于本地主机间的进程通信，典型应用是<strong>消息缓冲队列</strong>通信机制。</p>
<ul>
<li>直接通信<strong>原语</strong>的两种<strong>寻址</strong>方式：对称寻址方式，非对称寻址方式；</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/c6798b7e1dbb4c359e22b2178148c556.png"
alt="解决生产者问题" />
<figcaption aria-hidden="true">解决生产者问题</figcaption>
</figure>
</blockquote>
<blockquote>
<p><strong>间接（信箱）通信方式</strong>：</p>
<p><img
src="https://img-blog.csdnimg.cn/5a6bc268fd5b4f8eb83a2d45443e7cc4.png"
alt="信箱1" /><img
src="https://img-blog.csdnimg.cn/f5296ce1912542d88a316965673e955d.png"
alt="信箱2" /></p>
</blockquote>
</blockquote>
<p><strong>客户机-服务器系统</strong>：是当前主流
的通信实现机制，其主要实现方法有三类-套接字，远程过程调用，和远程
方法调用。</p>
<h3 id="线程定义引入原因">线程定义、引入原因</h3>
<p>定义：</p>
<blockquote>
<ul>
<li>在引入<strong>线程</strong>的操作系统中，<strong>线程</strong>能独立运行，是调度和分派的基本单位；</li>
<li>线程是由<strong>线程控制块（TCB）、程序计数器、寄存器集合和堆栈</strong>组成。它与同属一个<strong>进程</strong>的其它线程<strong>共享其代码段</strong>、<strong>数据段</strong>和其它<strong>操作系统资源</strong>(如打开文件和信号)；</li>
</ul>
</blockquote>
<p>引入原因：</p>
<blockquote>
<ul>
<li>比进程<strong>更小</strong>的能独立运行的基本单位—线程；</li>
<li>目的：提高系统内程序并发执行的程度；提高系统的吞吐量；</li>
</ul>
<p>传统<strong>进程</strong>两个基本属性：可拥有资源的独立单位；可处理器调度和分派的基本单位；</p>
<p>引入<strong>线程</strong>后，将<strong>进程</strong>两个基本属性分开：</p>
<ul>
<li><strong>进程</strong>作为<strong>分配资源</strong>的基本单位；</li>
<li>线程作为<strong>处理器调度和运行</strong>的基本单位，可以通过创建<strong>线程</strong>来完成任务，以减少程序并发执行时付出的时空开销，使操作系统具有更好的<strong>并发性</strong>；</li>
</ul>
</blockquote>
<p><strong>线程</strong>与<strong>进程</strong>的比较：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/b30b436f31cb46d68771ab494c10b386.png"
alt="线程" />
<figcaption aria-hidden="true">线程</figcaption>
</figure>
</blockquote>
<h2 id="第三章处理机调度">第三章：处理机调度</h2>
<h3
id="调度层次和调度算法目标衡量标准平均周转平均加权周转">调度层次和调度算法目标【衡量标准：平均周转、平均加权周转】</h3>
<p><strong>处理机调度</strong>：为<strong>待处理的作业</strong>或<strong>进程分配处理机</strong>的过程；</p>
<blockquote>
<p><strong>处理机调度</strong>的具体过程是由<strong>调度程序</strong>来完成的；</p>
<p>一个较为完善的操作系统会提供<strong>三级调度</strong>：</p>
<blockquote>
<ul>
<li><strong>高级</strong>调度：<strong>作业调度</strong>为进程活动做准备；</li>
<li><strong>中级</strong>调度：<strong>内存调度</strong>将暂时不能运行的进程挂起；</li>
<li><strong>低级</strong>调度：<strong>进程调度</strong>使进程正常活动起来；</li>
</ul>
</blockquote>
</blockquote>
<p>处理机调度算法的<strong>共同</strong>目标：</p>
<blockquote>
<ul>
<li><strong>资源利用率高</strong></li>
<li><strong>相对公平</strong>：尽量使诸进程都获得合理的<span
class="math inline">\(CPU\)</span>时间，不会发生进程饥饿现象；</li>
<li><strong>系统资源使用平衡</strong>：尽量使系统中的<span
class="math inline">\(CPU\)</span>和各种外部设备都能经常处于忙碌状态；</li>
<li><strong>策略强制执行</strong>：对所制订的策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟；</li>
</ul>
</blockquote>
<p>不同类型的操作系统的调度目标的差异性:</p>
<blockquote>
<p><strong>批处理</strong>系统：</p>
<blockquote>
<ul>
<li><strong>平均周转时间</strong>短</li>
<li>系统<strong>吞吐量</strong>高</li>
<li>处理机<strong>利用率</strong>高</li>
</ul>
</blockquote>
<p><strong>分时</strong>系统：</p>
<blockquote>
<ul>
<li>响应速度快</li>
<li>均衡性</li>
</ul>
</blockquote>
<p><strong>实时</strong>系统：</p>
<blockquote>
<ul>
<li>保证截止时间</li>
<li>可预测性</li>
</ul>
</blockquote>
</blockquote>
<h3 id="作业调度和进程调度算法">作业调度和进程调度算法</h3>
<p>周转时间：<code>作业完成时刻</code> - <code>作业到达时刻</code></p>
<p>带权周转时间 = <code>周转时间</code> / <code>服务时间</code></p>
<p>平均周转时间：<code>周转时间总时间</code> / <code>作业个数</code></p>
<p>平均带权周转时间 = <code>带权周转总时间</code> /
<code>作业个数</code></p>
<p><strong>作业调度</strong>：</p>
<blockquote>
<p><strong>FCFS</strong>（先来先服务）：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/7debe1c0ae0342969094fdebf724051c.png"
alt="FCFS" />
<figcaption aria-hidden="true">FCFS</figcaption>
</figure>
<p><span
class="math inline">\(\frac{(24-0)+(27-1)+(30-2)}{3}=26\)</span></p>
</blockquote>
<p><strong>SJF/SPF</strong>（短作业优先）：<strong>最佳</strong>调度算法（<del>MVP</del>）！</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/4e43f85fffeb454295d17e7ddb23591c.png"
alt="SJF" />
<figcaption aria-hidden="true">SJF</figcaption>
</figure>
<p>缺点：</p>
<blockquote>
<ul>
<li>必须预知作业的运行时间（这事很难！ ）。</li>
<li>对<strong>长作业</strong>非常不利，<strong>长作业</strong>的周转时间会明显地增长。由于该算法完全忽视作业的<strong>等待时间</strong>，可能使作业等待时间过长，出现<strong>饥饿</strong>现象。</li>
<li>该调度算法完全<strong>未考虑</strong>作业的<strong>紧迫程度</strong>，不能保证紧迫性作业能得到
及时处理。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>优先级调度算法</strong>：外部<strong>赋予</strong>作业相应的<strong>优先级</strong>，根据该<strong>优先级</strong>进行调度。</p>
<blockquote>
<ul>
<li><strong>静态</strong>优先级：在系统创建时确定的，<strong>一经确定</strong>之后在整个进程运行期间
<strong>不再改变</strong>；</li>
<li><strong>动态</strong>优先级：在进程运行前先确定一个优先级，进程运行过程中根据进
程等待时间的长短、执行时间的多少、输入输出信息量的大小等，通过
计算得到新的优先级；</li>
</ul>
</blockquote>
<p><strong>高响应比优先调度</strong>算法：为每个作业引入一个<strong>动态优先级</strong>，令它
随等待时间增加而增加，这使<strong>长作业</strong>的优先级在等待期间<strong>不断地提</strong>升，等到足够的时间后，必然有机会获得处理机。</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/fc3f1696450f44b588d943ec3cbcdf04.png"
alt="高响应比优先调度" />
<figcaption aria-hidden="true">高响应比优先调度</figcaption>
</figure>
</blockquote>
</blockquote>
<p><strong>进程调度</strong>：非抢占方式；抢占方式。</p>
<blockquote>
<p><strong>时间片轮转（RR）调度算法</strong>：</p>
<blockquote>
<p>思想：</p>
<blockquote>
<p>系统中所有的就绪进程按照<strong>FCFS原则排成一个队列</strong>，每次调度时将<span
class="math inline">\(CPU\)</span>分派给队首进程，让其执行<strong>一个时间片</strong>。在一个时间片结束时，发生<strong>时钟中断</strong>。调度程序<strong>暂停当前进程的执行</strong>，将其送到就绪队列的<strong>末尾</strong>，并通过<span
class="math inline">\(CPU\)</span>现场切换执行当前的队首进程；</p>
</blockquote>
<p>特点：</p>
<blockquote>
<ul>
<li>就绪队列中的所有进程<strong>都有机会</strong>获得处理器运行；</li>
<li>可<strong>提高</strong>进程并发性和资源利用率；</li>
<li><strong>缩短</strong>响应时间；</li>
</ul>
</blockquote>
<p><strong>时间片长度的选择</strong>会直接影响系统开销和响应时间：</p>
<blockquote>
<ul>
<li><strong>时间片过短</strong>：进程调度次数频繁，加重系统开销；</li>
<li><strong>时间片过大</strong>：大到一个进程足以完成其全部运行工作所需的时间，那么时间片
轮转法就<strong>退化为FCFS</strong>，对<strong>短进程不友好</strong>；</li>
<li><strong>较为可取的时间片大小</strong>：略大于一次典型交互的时间。</li>
</ul>
</blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/ef9ee6a0d80546aab41117cef502b5c0.png"
alt="RR" />
<figcaption aria-hidden="true">RR</figcaption>
</figure>
<p><strong>例题</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/edd5a49f7e3844ddb6e851cd44e8ff1d.png"
alt="例题1" />
<figcaption aria-hidden="true">例题1</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/31be8cbbcd2b49a2920f2fa428e48df5.png"
alt="例题2" />
<figcaption aria-hidden="true">例题2</figcaption>
</figure>
</blockquote>
</blockquote>
<p><strong>优先调度</strong>算法：把处理机分配给就绪队列中<strong>优先级最高</strong>的进程。</p>
<blockquote>
<p>确定优先级的<strong>主要依据</strong>：</p>
<blockquote>
<ul>
<li>进程类型：系统进程的优先级较高，用户进程的优先级较低；</li>
<li>进程对资源的需求：对资源要求少的进程的优先级较高；</li>
<li>用户要求：紧迫程度高的进程的优先级较高；</li>
</ul>
</blockquote>
</blockquote>
<p><strong>多级队列调度</strong>算法：根据进程的<strong>某些属性</strong>将就绪进程队列<strong>分成多个独立队列</strong>，进程永久地从属于<strong>特定队列</strong>，且每个队列有自己的调度算法和不同的优先级。</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/6c1ccb3aa6364b8bbfcf599ff5aae691.png"
alt="多级队列调度" />
<figcaption aria-hidden="true">多级队列调度</figcaption>
</figure>
</blockquote>
<p><strong>多级反馈队列调度</strong>算法：又称<strong>多队列轮转法</strong>，该方法<strong>不必</strong>事先知道各进程的执行时间就可以较好地满足各种类型进程的调度需要，是目前公认的一种较好的进程调度算法。</p>
<blockquote>
<p>过程：</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/cd321fdeb93a4e878f69de90c03714c2.png"
alt="多级反馈队列调度" />
<figcaption aria-hidden="true">多级反馈队列调度</figcaption>
</figure>
</blockquote>
<blockquote>
<p>性能：</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/6d791cd2154748ee91928d239aa15c2b.png"
alt="性能" />
<figcaption aria-hidden="true">性能</figcaption>
</figure>
</blockquote>
<p><strong>公平原则调度</strong>算法：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/2e83c61a52924958a954eccfe8a72aac.png"
alt="公平原则调度" />
<figcaption aria-hidden="true">公平原则调度</figcaption>
</figure>
</blockquote>
</blockquote>
<h3 id="死锁全章节">死锁全章节</h3>
<p><strong>概念</strong>：</p>
<blockquote>
<ul>
<li><strong>死锁</strong>是指在一个进程集合中的<strong>所有进程</strong>都在等待<strong>只能由该集合中的其它进程才能引发的事件</strong>而无限期地僵持下去的局面；</li>
<li>陷入僵持状态的<strong>死锁进程</strong>所占用的资源或者<strong>需要与它们进行某种合作的其
它进程</strong>就会相继陷入死锁，最终可能导致整个系统处于瘫痪状态；</li>
</ul>
</blockquote>
<p><strong>资源分配图</strong>描述<strong>死锁</strong>问题：</p>
<blockquote>
<ul>
<li>系统资源分配图是一个<strong>有向图</strong>；</li>
<li>如果资源分配图中<strong>没有环路</strong>，那么系统就不会陷入<strong>死锁状态</strong>；</li>
<li>如果<strong>存在环路</strong>，系统就<strong>有可能</strong>出现死锁，但不一定（如果系统中的每类资源都仅有<strong>一个</strong>，存在环路则必定出现死锁）；</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/e8d11bc5d285406f8f0ff5e93c1f1565.png"
alt="资源分配图" />
<figcaption aria-hidden="true">资源分配图</figcaption>
</figure>
</blockquote>
<p><strong>死锁产生原因</strong>：</p>
<blockquote>
<ol type="1">
<li>竞争资源</li>
<li>各进程之间的推进顺序不当</li>
</ol>
<p>产生死锁四个<strong>必要条件</strong>：</p>
<blockquote>
<ol type="1">
<li><strong>互斥</strong>条件</li>
</ol>
<blockquote>
<p>在一段时间内，某个资源只能被一个进程使用。</p>
</blockquote>
<ol start="2" type="1">
<li><strong>请求和保持</strong>条件（<strong>部分分配</strong>条件）</li>
</ol>
<blockquote>
<p>已经获取了一部分资源的进程若又提出新资源申请，且新资源已被别的进程占用时，该进程阻塞自己，并<strong>在保持已经获取到的资源的同时</strong>等待其他进程释放其它资源。(阻塞时，不释放自身获得的资源)</p>
</blockquote>
<ol start="3" type="1">
<li>不剥夺（<strong>不可抢占</strong>）条件</li>
</ol>
<blockquote>
<p>进程所获得的资源在<strong>未使用完毕前</strong>，其他进程不能强行剥夺。</p>
</blockquote>
<ol start="4" type="1">
<li><strong>环路等待 （循环等待）</strong>条件</li>
</ol>
<blockquote>
<p>必然存在进程-资源循环等待链，链中<strong>每一个进程已获得的某些资源</strong>同时<strong>被下
一个进程所请求</strong> 。</p>
</blockquote>
<blockquote>
<p>Q：出现“<strong>环路等待条件</strong> ” 是不是
就必定发生<strong>死锁</strong>了？</p>
<p>A：<strong>死锁</strong>要求的条件<strong>更严苛</strong>。死锁中的进程所请求的某资源必须由环路上的进程释放提供。但实际上，如果所请求的资源同时也可以<strong>由环路外的进程释放提供</strong>（同类资源不止一个），则<strong>不一定死锁</strong>。</p>
</blockquote>
</blockquote>
</blockquote>
<p><strong>死锁处理方法</strong>：</p>
<blockquote>
<ol type="1">
<li>死锁预防</li>
</ol>
<blockquote>
<p>比较简单和直观的一种方法。采用<strong>事先预防</strong>策略，为系统和进程<strong>设置</strong>某些限定条件，从根本上破除产生死锁的四个必要条件中的一个或多个，以达到预防效果。</p>
</blockquote>
<ol start="2" type="1">
<li>死锁避免</li>
</ol>
<blockquote>
<p>该方法也属于<strong>事先预防</strong>策略。它<strong>无需</strong>在系统中<strong>设定</strong>严格的限定条件，而是允许系统运行，但在为进程分配资源之前，先采用特殊算法检查并防止系统进入<strong>不安全状态</strong>，
从而避免死锁产生</p>
</blockquote>
<ol start="3" type="1">
<li>死锁的检测和解除</li>
</ol>
<blockquote>
<p>事先<strong>不采取</strong>任何限定措施，在分配资源时也<strong>不检查</strong>是否会导致系统不安全。它<strong>允许系统产生死锁</strong>，但需要在系统中<strong>设置特定的检测机构</strong>，及时<strong>检测出死锁的发生</strong>，并精确地确定与死锁有关的进程和资源，以便<strong>及时采取措施将死锁状态解除</strong>。</p>
</blockquote>
<p>上述处理死锁的方法，<strong>防范程度逐渐减弱</strong>，但<strong>资源利用率有提高</strong>，也减少了
进程因资源因素而阻塞的频度（即<strong>并发程度有提高</strong>）</p>
<p>下面具体介绍上述三种方法）</p>
</blockquote>
<p><code>预防死锁</code>：</p>
<blockquote>
<p>破除死锁产生的四个必要条件中的一个或几个；</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/728948855bc445719fd678a4c45f196b.png"
alt="破坏请求和保持" />
<figcaption aria-hidden="true">破坏请求和保持</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/61956355120a46ba9960b1cd6f15186b.png"
alt="破坏不可抢占" />
<figcaption aria-hidden="true">破坏不可抢占</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/80172e8d2c0649c5ad05cfc71bf120e9.png"
alt="破坏环路等待" />
<figcaption aria-hidden="true">破坏环路等待</figcaption>
</figure>
</blockquote>
<p><code>死锁避免</code>：</p>
<blockquote>
<p>安全转态和不安全转态：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/f908a5bd8fb34100aef028783e253653.png"
alt="安全状态1" />
<figcaption aria-hidden="true">安全状态1</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/c3c32f2a0f514edcae63d704c4592359.png"
alt="不安全状态" />
<figcaption aria-hidden="true">不安全状态</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/9249f3c8c09048fb858186998a25fb8a.png"
alt="关系" />
<figcaption aria-hidden="true">关系</figcaption>
</figure>
</blockquote>
<p><strong>银行家算法</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/6c7577a579e341f38e95ed0148647d29.png"
alt="银行家1" />
<figcaption aria-hidden="true">银行家1</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/47171aaa1e0746f8a21b8f2377f4ff8d.png"
alt="银行家2" />
<figcaption aria-hidden="true">银行家2</figcaption>
</figure>
<p>相关数据结构：</p>
<blockquote>
<ul>
<li><strong>可用资源向量</strong><span
class="math inline">\(Available\)</span>：<span
class="math inline">\(Available[j]=k\)</span>，表示系统中现有<span
class="math inline">\(R_j\)</span>类资源<span
class="math inline">\(k\)</span>个。</li>
<li><strong>最大需求矩阵</strong><span
class="math inline">\(Max\)</span>：<span class="math inline">\(Max[i,
j]=k\)</span>，则表示进程<span
class="math inline">\(P_i\)</span>需要<span
class="math inline">\(R_j\)</span>类资源<span
class="math inline">\(k\)</span>个。</li>
<li><strong>已分配资源矩阵</strong><span
class="math inline">\(Allocation\)</span>：<span
class="math inline">\(Allocation [i, j]=k\)</span>，则表示进程<span
class="math inline">\(P_i\)</span>当前分配到<span
class="math inline">\(k\)</span>个<span
class="math inline">\(R_j\)</span>类资源。</li>
<li><strong>需求矩阵</strong><span
class="math inline">\(Need\)</span>：<span class="math inline">\(Need[i,
j]=k\)</span>，则表示进程<span
class="math inline">\(P_i\)</span>尚需<span
class="math inline">\(k\)</span>个<span
class="math inline">\(R_j\)</span>类资源才能完成其任务。</li>
</ul>
</blockquote>
<p>步骤：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/a325d7259aca4556aeca6db794529a48.png"
alt="银行家2" />
<figcaption aria-hidden="true">银行家2</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/2302be0362a74a43b415e22b9b13951b.png"
alt="银行家3" />
<figcaption aria-hidden="true">银行家3</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/b42baf31e9134dfab2a8889abb303804.png"
alt="银行家4" />
<figcaption aria-hidden="true">银行家4</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/2a508d094aae4aeda415ddd14101274f.png"
alt="银行家5" />
<figcaption aria-hidden="true">银行家5</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/a3f10aebf797433fbcd56ef8d828de56.png"
alt="银行家6" />
<figcaption aria-hidden="true">银行家6</figcaption>
</figure>
</blockquote>
<ul>
<li><strong>银行家算法</strong>用于避免死锁非常有效；</li>
<li><strong>缺乏实用价值</strong>：很少由进程能够在运行前就知道其所需资源的最大值；进程数是动态变化的；资源也有可能突然不可用（例如坏掉了）。</li>
</ul>
</blockquote>
</blockquote>
<p><code>死锁的检测与解除</code>：</p>
<blockquote>
<p>死锁的检测：</p>
<blockquote>
<p><strong>简化资源分配图</strong>法：<strong>孤立</strong>节点。</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/2315ee121aee450abd9ba1d43f13a9e5.png"
alt="资源分配简化" />
<figcaption aria-hidden="true">资源分配简化</figcaption>
</figure>
<ul>
<li><strong>死锁定理</strong>：系统状态S为<strong>死锁</strong>状态的<strong>充分条</strong>件是当且仅当状态S的资源分配
图是<strong>不可完全简化的</strong>。</li>
</ul>
</blockquote>
</blockquote>
<p>死锁的解除：</p>
<blockquote>
<p><strong>资源剥夺（抢占）</strong>法：从一些进程处剥夺（抢占）足够数量的资源给另一些进程，使获得资源的进程能继续运行直至完成。</p>
<p><strong>终止进程</strong>法：将陷入死锁的进程<strong>强制终止</strong>并回收分配给该进程的所有资源，分为<strong>全部撤销</strong>和<strong>最小代价撤销</strong>两种不同方法。</p>
</blockquote>
</blockquote>
<p>例题：(无解析的均为个人答案，如有歧义，随时撅我)</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/7913cb41bc384d13b2355495ff07d867.png"
alt="例题1" />
<figcaption aria-hidden="true">例题1</figcaption>
</figure>
<blockquote>
<p><strong>解析</strong>：</p>
<p><strong>死锁预防</strong>典型的是<strong>顺序资源分配法</strong>，限制进程申请资源的顺序!后面的进程只能申请编号更大的资源。</p>
<p>死锁避免算法，典型的是<strong>银行家算法</strong>，<strong>不会限制申请</strong>资源的顺序，但是<strong>会限制分配资源</strong>的顺序，避免进入不安全状态！因此，需要知道全局性的资源需求矩阵以及资源总量。</p>
<p>死锁检测，是最宽松的，啥也不限制，只有当出现死锁且被检测到时才会去处理解除。因此，这种灵活性的算法在Unix上实现了。常用资源分配图结合死锁定理检测。</p>
<p>综上，II、III才是正确的。要明白限制用户申请资源的顺序是很大的限制，限制分配资源的顺序是稍微宽松些的限制，检测是不做限制。</p>
<p>还有，这里有个词：用户。似乎很困惑，其实指的是程序员，或者写代码需要控制进程申请资源的人。简单抽象到进程即可。</p>
</blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/bc81b4fe2bbf4f9ca60240b117145154.png"
alt="例题2" />
<figcaption aria-hidden="true">例题2</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/9cabbd70ac0644f4877c13d6f10ffd5b.png"
alt="例题3" />
<figcaption aria-hidden="true">例题3</figcaption>
</figure>
</blockquote>
<h2 id="第四章存储器管理">第四章：存储器管理</h2>
<h3
id="固定分区动态分区方案原理分区分配算法首次最先最佳最坏">固定分区、动态分区方案【原理、分区分配算法：首次（最先）、最佳、最坏】</h3>
<p><code>固定分区</code>：把内存的用户空间划分为若干个固定大小的区域，由多道环境下的各并发进程共享；每个区域中只装入一个用户程序。</p>
<blockquote>
<ul>
<li><strong>缺点</strong>：每个分区大小固定，装入的用户程序不能超过分<strong>区大小</strong>。这就导致分区内部可能产生不可利用的<strong>零头</strong>（fragmentation）
(也称“碎片”)。</li>
</ul>
</blockquote>
<p><code>动态分区</code>（可变分区）：根据进程的实际需要，<strong>动态地</strong>对内存进行划分。</p>
<blockquote>
<ul>
<li>改变了即使是<strong>小进程也要占大分区</strong>的内存浪费现象，显著地提高了存储器的利用率。</li>
</ul>
<p><strong>分配算法</strong>：</p>
<blockquote>
<p><strong>首次适应</strong>算法（FF）：</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/8379f30d94434532b8061dba72c7cd20.png"
alt="FF" />
<figcaption aria-hidden="true">FF</figcaption>
</figure>
</blockquote>
<blockquote>
<p><strong>最佳适应</strong>算法（BF）：</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/e75407cfd92b47aa9dbf3c7055bde0fa.png"
alt="BF" />
<figcaption aria-hidden="true">BF</figcaption>
</figure>
</blockquote>
<blockquote>
<p><strong>最坏适应</strong>算法：</p>
<figure>
<img
src="C:/Users/A%20Fei/AppData/Roaming/Typora/typora-user-images/image-20221208174053947.png"
alt="image-20221208174053947" />
<figcaption aria-hidden="true">image-20221208174053947</figcaption>
</figure>
</blockquote>
<p>例题：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/14beff0ac3f94990b6b3df83cf062701.png"
alt="例题" />
<figcaption aria-hidden="true">例题</figcaption>
</figure>
</blockquote>
</blockquote>
<h3
id="页式存储管理方案全章节不包括多级页表和反置页表">页式存储管理方案【全章节（不包括：多级页表和反置页表）】</h3>
<blockquote>
<p><strong>连续分配方式</strong>相对简单，但带来严重的碎片问题，导致内存利用率低。为解决该问
题，操作系统引入<strong>离散分配方式</strong>。它将用户程序<strong>离散地分配</strong>到内存的多个不相邻接的区域中。</p>
<p>三种分配方式：<strong>分页存储管理</strong>方式，<strong>分段存储管理</strong>方式，<strong>段页式存储管理</strong>方式；</p>
</blockquote>
<p>多图预警【开启ppt模式，<del>懒得总结了</del>】</p>
<blockquote>
<p>分页存储管理：</p>
<blockquote>
<p><img
src="https://img-blog.csdnimg.cn/c46a3f2e19d14e0ca002521071515b9b.png"
alt="1" /><img
src="https://img-blog.csdnimg.cn/6d0f1e84d6654427be06f2c067262946.png"
alt="2" /><img
src="https://img-blog.csdnimg.cn/2d69c860427148d18bb92a6ff5d37fbc.png"
alt="3" /><img
src="https://img-blog.csdnimg.cn/4aefadacd4f3436da53ceacac26ee831.png"
alt="4" /><img
src="https://img-blog.csdnimg.cn/0ea739a336184da79fcbbff76ca74a80.png"
alt="5" /><img
src="https://img-blog.csdnimg.cn/d48cf179fbc6486f826adb1ac08865b4.png"
alt="6" /></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/5178e0d35b534a58b2696c929039746c.png"
alt="7" />
<figcaption aria-hidden="true">7</figcaption>
</figure>
<p><img
src="https://img-blog.csdnimg.cn/0439ff0afabf4380b2b29e487a5008f0.png"
alt="8" /><img
src="https://img-blog.csdnimg.cn/ae142db4a04f444f8462ecf631bb90e1.png"
alt="9" /></p>
<p><img
src="https://img-blog.csdnimg.cn/20b1d50d2ef440d484dfacf45a81de20.png"
alt="10" /><img
src="https://img-blog.csdnimg.cn/52081fa91c7d4aeb9e2c404151c7034c.png"
alt="11" /><img
src="https://img-blog.csdnimg.cn/226838dcbcd24cba8b8bb01013d643b6.png"
alt="13" /></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/8398c6b2cd394453a308c6866e925345.png"
alt="12" />
<figcaption aria-hidden="true">12</figcaption>
</figure>
</blockquote>
</blockquote>
<h3
id="段式存储管理方案引入原因段表段页式存储管理方式">段式存储管理方案：引入原因、段表、段页式存储管理方式</h3>
<p><code>引入原因</code>：</p>
<blockquote>
<p>分页存储管理方式可以提高内存利用率（<strong>系统角度方便管理</strong>）；分段存储管理方式的提出则是从<strong>用户角度</strong>出发，方便用户编程、更好地实现<strong>信息共享和保护</strong>，并且分段存
储管理方式非常适合处理数据<strong>动态增长</strong>情况和适合于<strong>动态链接</strong>。</p>
</blockquote>
<p><code>段表</code>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/b487c4752c8147ac81de0c3e2bf18d33.png"
alt="段表" />
<figcaption aria-hidden="true">段表</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/08ecec0259a049bf97e88c69f6fe17fd.png"
alt="地址变换" />
<figcaption aria-hidden="true">地址变换</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/72dbeef6cdc04ecc81f2cd2d93cf2b56.png"
alt="练习" />
<figcaption aria-hidden="true">练习</figcaption>
</figure>
</blockquote>
<p>·<code>分页和分段的区别</code>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/4acd353f928d44148826059f324ead5c.png"
alt="区别" />
<figcaption aria-hidden="true">区别</figcaption>
</figure>
</blockquote>
<p><code>段页式存储管理</code>：</p>
<blockquote>
<p><img
src="https://img-blog.csdnimg.cn/6d1f589d0a1e4da0af09b5d4ff89ab49.png"
alt="引入" /><img
src="https://img-blog.csdnimg.cn/69154143ce7f41de8fca1e5b61d5dd65.png"
alt="基本原理" /></p>
<figure>
<img
src="https://img-blog.csdnimg.cn/0406334376d8437bbf624e06c7dce781.png"
alt="3" />
<figcaption aria-hidden="true">3</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/2e9cbec91c80471aab9dba25bfb819ae.png"
alt="4" />
<figcaption aria-hidden="true">4</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/b08b8d52078440b090c17d024b45ef23.png"
alt="5" />
<figcaption aria-hidden="true">5</figcaption>
</figure>
</blockquote>
<h2 id="第五章虚拟存储器">第五章：虚拟存储器</h2>
<h3
id="引入原因定义大小特征理论依据">引入原因、定义、大小、特征、理论依据</h3>
<p><code>引入原因</code>：</p>
<blockquote>
<p>传统存储器管理方式可能出现两种情况：</p>
<ol type="1">
<li><strong>作业很大</strong>，其所要求的内存空间超过了内存总容量，作业不能全部被装入内存，致使该作业<strong>无法运行</strong>；</li>
<li><strong>大量作业要求运行</strong>，但由于内存容量不足以容纳所有这些作业，只能将<strong>少数作业</strong>装入内存让它们<strong>先运行</strong>，而将其它<strong>大量的作业</strong>留在外存上<strong>等待</strong>；</li>
</ol>
<p>上述情况都因：<strong>内存容量不够大</strong>，而导致，解决方法：</p>
<blockquote>
<ol type="1">
<li><strong>物理</strong>上增加内存容量：会受到机器自身的限制，并且会增加系统成本；</li>
<li><strong>逻辑</strong>上扩充内存：<strong>虚拟存储</strong>技术；</li>
</ol>
</blockquote>
</blockquote>
<p><code>虚拟存储技术定义</code>：</p>
<blockquote>
<p>是指具有<strong>请求调入功能</strong>和<strong>置换</strong>功能，能从<strong>逻辑上</strong>对内存容量加以扩充的一种存储器系统；</p>
<blockquote>
<p>当用户看到自己的程序能在系统中正常运行时，会认为系统所具有的内存容量比自己的程序大
。或者说，用户所感觉到的内存容量会比实际内存容量大。但用户所看到的大容量只是一种错觉，是虚的，故人们把这样的存储器称为虚拟存储器
。</p>
</blockquote>
<ul>
<li><strong>虚拟存储器</strong>的<strong>逻辑容量</strong>由<strong>内存</strong>容量和<strong>外存</strong>容量共同决定，<strong>运行速度</strong>接近于<strong>内存</strong>速
度，<strong>成本</strong>接近于<strong>外存</strong>。可见，虚拟存储技术是一种性能优越的存储器管理技术；</li>
</ul>
</blockquote>
<p><code>虚拟存储技术特征</code>：</p>
<blockquote>
<ol type="1">
<li><strong>多次性</strong>：相对于传统存储器管理方式的<strong>一次性</strong>，作业无需一次性地全部装入内存；</li>
<li><strong>对换性</strong>：相对于传统存储器管理方式的<strong>驻留性</strong>，允许在作业运行过程中进行<strong>换入
、 换出</strong>内存操作；</li>
<li><strong>虚拟性</strong>：能从逻辑上扩充内存容量，使用户感觉到的内存容量大于实际内存容量。
<strong>虚拟性</strong>是以<strong>多次性</strong>和<strong>对换性</strong>为基础的；而后二者必须建立在<strong>离散分配</strong>的基础上；</li>
</ol>
</blockquote>
<p><code>虚拟存储器实现方法</code>：</p>
<blockquote>
<p><strong>请求分页</strong>系统（<strong>页式虚拟存储系统</strong>
）：分页系统的基础上，增加了<strong>请求调页</strong>功能和<strong>页面置换</strong>功能；</p>
<p><strong>请求分段</strong>系统（<strong>段式虚拟存储系统</strong> ）：
分段系统的基础上，增加了<strong>请求调段</strong>功能和<strong>分段置换</strong>功能；</p>
</blockquote>
<h3
id="请求分页调页时机何处调页技术支持硬件软件缺页中断处理过程">请求分页：调页时机、何处调页、技术支持【硬件、软件】、缺页中断处理过程</h3>
<p><code>调页时机</code>：</p>
<blockquote>
<p><strong>请求调页</strong>策略：</p>
<blockquote>
<ul>
<li>进程运行时，发现所需页面不在内存，立即提出请求，<span
class="math inline">\(OS\)</span>将其所需页面调入内存；</li>
<li><strong>缺点</strong>：每次只调入一页，系统开销较大，增加了磁盘I<span
class="math inline">\(/O\)</span>的启动频率；</li>
</ul>
</blockquote>
<p><strong>预调页</strong>策略：</p>
<blockquote>
<ul>
<li>如果进程的许多页存放在外存的一个连续区域中，一次调入若干个相邻的页比每次调入一页<strong>更高效</strong>；</li>
<li><strong>缺点</strong>：但若其中大多数都未被访问，则又是低效的；</li>
</ul>
<p><strong>改进措施</strong>：基于<strong>预测的预调页</strong>策略，将那些预计不久之后便会被访问的页面预先调入内存。如果预测较准确，效率就会很高；</p>
<blockquote>
<ul>
<li>进程第一次调入内存时，将程序员指出的那些页先调入内存；</li>
<li>采用<strong>工作集</strong>的系统，每当程序被调度运行时，将<strong>工作集</strong>中的所有页面调入内存；</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<p><code>何处调页</code>：</p>
<blockquote>
<p><strong>请求分页系统</strong>具有<strong>对换</strong>功能，其外存分为两部分：存放文件的<strong>文件区</strong>和存放对换页面的<strong>对换区</strong>。<strong>对换区</strong>采用连续分配方式，<strong>文件区</strong>采用离散分配方式，所以对换区的数据存取（磁盘<span
class="math inline">\(I/O\)</span>）速度比文件区的快；</p>
<p>何处调页分为三种情况：</p>
<blockquote>
<ol type="1">
<li>系统<strong>拥有</strong>足够的<strong>对换区空间</strong>，这时可以全部从<strong>对换区</strong>调入所需页面，以提高调页速度；</li>
<li>系统<strong>缺少</strong>足够的<strong>对换区空间</strong>，这时凡是不会被修改的文件，都直接从<strong>文件区</strong>调入；而当换出这些页面时，由于它们<strong>未被修改</strong>，则不必再将它们重写到磁盘(换出)，以后再调入时，仍从<strong>文件区</strong>直接调入；但对于那些<strong>被修改</strong>的部分，
在将它们换出时便须调到<strong>对换区</strong>，以后需要时再从<strong>对换区</strong>调入；</li>
<li><span
class="math inline">\(UNIX\)</span>方式：凡是<strong>未运行过</strong>的页面，都从<strong>文件区</strong>调入。曾经<strong>运行过但又被换出</strong>的页面，由于是被放在<strong>对换区</strong>，下次调入时从<strong>对换区</strong>调入；</li>
</ol>
</blockquote>
</blockquote>
<p><code>缺页率</code>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/7670f469234a46c6b3047244672fb1f8.png"
alt="缺页率" />
<figcaption aria-hidden="true">缺页率</figcaption>
</figure>
</blockquote>
<p><code>请求分页的硬件支持</code>：一定容量的<strong>内存</strong>和<strong>外存</strong>，有<strong>请求页表机制</strong>，<strong>缺页中断</strong>机构和<strong>地址变换</strong>机构；</p>
<p><code>缺页中断处理过程</code>：</p>
<blockquote>
<p><strong>缺页中断</strong>：程序在执行时，当访问的页面<strong>不在</strong>内存时，便产生缺页中断；</p>
<p><strong>缺页中断</strong>是一种特殊的中断，同样需要经历诸如<strong>保护CPU环境</strong>、<strong>分析中断原因</strong>、<strong>转
入缺页中断处理程序</strong>进行处理、<strong>恢复CPU环境</strong>等几个步骤；</p>
<p>与一般中断的不同：</p>
<blockquote>
<ol type="1">
<li>一般中断是<strong>一条指令完成后</strong>中断，而缺页中断是在<strong>一条指令执行时</strong>中断；</li>
<li><strong>一条</strong>指令执行时可能产生<strong>多个</strong>缺页中断；</li>
</ol>
</blockquote>
</blockquote>
<h3 id="淘汰算法optfifolru">淘汰算法：OPT、FIFO、LRU</h3>
<p><span class="math inline">\(OPT\)</span>：其所选择的被淘汰
页面将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面。（类似上帝视角？总之是所有方案中最优的那个）</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/4edc36dc81814b3cadfbabc0e06165bf.png"
alt="OPT" />
<figcaption aria-hidden="true">OPT</figcaption>
</figure>
</blockquote>
<p><span
class="math inline">\(FIFO\)</span>（先进先出）：淘汰最先进入内存的页面，即选择
在内存中驻留时间最久的页面予以淘汰。</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/4d716b5223164f88adad5076bcc8b72f.png"
alt="FIFO" />
<figcaption aria-hidden="true">FIFO</figcaption>
</figure>
</blockquote>
<p><span
class="math inline">\(LRU\)</span>（最近最久未使用）：根据页面调入内存后的使用情况来进行置换决策的（表现出<strong>时间局部性</strong>的特征）。</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/3357b214ce044902bd2533c4548cab6d.png"
alt="在这里插入图片描述" />
<figcaption aria-hidden="true">在这里插入图片描述</figcaption>
</figure>
<p><strong>寄存器实现LRU</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/965cbdf62d5042598888b3e63fadfe83.png"
alt="寄存器实现LRU" />
<figcaption aria-hidden="true">寄存器实现LRU</figcaption>
</figure>
</blockquote>
<p><strong>栈实现LRU</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/e6df5ec768fa408da6b1f323be858f75.png"
alt="栈实现LRU" />
<figcaption aria-hidden="true">栈实现LRU</figcaption>
</figure>
</blockquote>
</blockquote>
<h2 id="第六章输入输出系统">第六章：输入输出系统</h2>
<h3 id="io-系统组成">I/O 系统组成</h3>
<blockquote>
<p><span
class="math inline">\(I/O\)</span><strong>主要任务</strong>：完成用户提出的<span
class="math inline">\(I/O\)</span>请求，提高<span
class="math inline">\(I/O\)</span>速率，以及提高设备的利用率，并
能为更高层的进程方便地使用这些设备提供手段。</p>
<p><span
class="math inline">\(I/O\)</span><strong>基本功能</strong>：</p>
<blockquote>
<ul>
<li>隐藏物理设备的细节;</li>
<li>与设备的无关性;</li>
<li>提高处理机和<span
class="math inline">\(I/O\)</span>设备的利用率;</li>
<li>对<span class="math inline">\(I/O\)</span>设备进行控制;</li>
<li>确保对设备的正确共享;</li>
<li>错误处理;</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><span
class="math inline">\(I/O\)</span><strong>系统四个层次</strong>：</p>
<ol type="1">
<li>用户层<span class="math inline">\(I/O\)</span>软件；</li>
<li>设备独立性软件；</li>
<li>设备驱动程序；</li>
<li>中断处理程序；</li>
</ol>
</blockquote>
<h3 id="设备分类">设备分类</h3>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/dfc78c6350864a8190ce5e8313e2fdc9.png"
alt="IO设备分类" />
<figcaption aria-hidden="true">IO设备分类</figcaption>
</figure>
</blockquote>
<h3 id="设备独立性">设备独立性</h3>
<blockquote>
<p>设备无关性（<strong>设备独立性</strong>）基本含义是：应用程序中所用的设备，不局限于使用某个具体的物理设备。</p>
</blockquote>
<h3 id="spooling-技术">Spooling 技术</h3>
<p><strong>多道程序技术</strong>：通过分时共享将一个物理<strong>CPU</strong>虚拟为多个逻辑CPU，供多道程序共享。</p>
<p><strong>假脱机技术</strong>：将一个<strong>物理设备</strong>虚拟出多个逻辑设备，供多个用户共享</p>
<blockquote>
<p><span class="math inline">\(Spooling\)</span>技术：</p>
<blockquote>
<p>当系统中引入<strong>多道程序技术</strong>后，可以利用其中的一道程序，<strong>模拟</strong>脱机<strong>输入</strong>时
的外围控制机，再利用其中的另一道程序，<strong>模拟</strong>脱机<strong>输出</strong>时的外围控制机，
在主机的直接控制下，实现以前的脱机输入/输出功能。此时的<strong>外围操作</strong>和
<strong>CPU对数据的处理</strong>同时进行。这种<strong>在联机情况下</strong>实现的<strong>同时外围操作</strong>的技术
称为<span
class="math inline">\(SPOOLing\)</span>技术，或称为<strong>假脱机技术</strong>。</p>
</blockquote>
<ul>
<li><span
class="math inline">\(SPOOLing\)</span>技术是对<strong>脱机输入/输出系统</strong>的模拟；</li>
<li><span
class="math inline">\(SPOOLing\)</span>系统建立在<strong>通道技术</strong>和<strong>多道程序技术</strong>的基础上，以高速随机外存(通常为<strong>磁盘</strong>)为后援存储器；</li>
</ul>
<p>特点：</p>
<blockquote>
<ol type="1">
<li>提高了<span
class="math inline">\(I/O\)</span>的速度：对低速设备操作<strong>转换为</strong>对<strong>磁盘缓冲区</strong>操作；</li>
<li>将独占设备<strong>改造为</strong>共享设备：没有为进程分配设备，只是在磁盘缓冲区分配空闲盘块和<span
class="math inline">\(I/O\)</span>请求表；</li>
<li>实现了<strong>虚拟设备</strong>功能：eg.假脱机打印；</li>
</ol>
</blockquote>
</blockquote>
<h3
id="设备分配数据结构考虑因素分配过程">设备分配：数据结构、考虑因素、分配过程</h3>
<p><strong>设备分配</strong>：根据用户的<span
class="math inline">\(I/O\)</span>请求分配所需的设备，分配的总原则是充分发挥设备的使用效率。</p>
<p><strong>考虑因素</strong>：</p>
<ol type="1">
<li>设备的<strong>固有属性</strong>；</li>
<li>设备<strong>分配算法</strong>；</li>
<li>设备<strong>分配的安全性</strong>；</li>
</ol>
<p><strong>数据结构</strong>：</p>
<blockquote>
<ol type="1">
<li>设备控制表（DCT）：系统为每个设备都配置了一张设备控制表，记录设备的情况。</li>
<li>控制器控制表（COCT）：系统为每个控制器都配置了一张控制器控制表，记录控制器的情况。</li>
<li>通道控制表（CHCT）：每个通道都有一张通道控制表 。</li>
<li>系统设备表（SDT）：整个系统只有<strong>一张系统设备表</strong>，记录已连接到系统中的全部物理设备的情况。<strong>每个设备</strong>占一个<strong>表目</strong>
。</li>
</ol>
</blockquote>
<p><strong>分配过程</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/8b2f715d65154116bc9f2dcc34daeea0.png"
alt="分配过程" />
<figcaption aria-hidden="true">分配过程</figcaption>
</figure>
</blockquote>
<h3
id="缓冲技术引入原因单缓冲双缓冲缓冲池">缓冲技术：引入原因、单缓冲、双缓冲、缓冲池</h3>
<p><strong>引入缓冲区的原因</strong>：</p>
<ol type="1">
<li>缓和<span class="math inline">\(CPU\)</span>与<span
class="math inline">\(I/O\)</span>设备间速度不匹配的矛盾；</li>
<li>减少对<span
class="math inline">\(CPU\)</span>的中断频率，放宽对<span
class="math inline">\(CPU\)</span>中断响应时间的限制；</li>
<li>解决数据粒度不匹配的问题；</li>
<li>提高<span class="math inline">\(CPU\)</span>和<span
class="math inline">\(I/O\)</span>设备之间的并行性；</li>
</ol>
<p><strong>单缓冲：</strong></p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/c18cddb21e434e12a12a63c36c14326f.png"
alt="单缓冲" />
<figcaption aria-hidden="true">单缓冲</figcaption>
</figure>
</blockquote>
<p><strong>双缓冲</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/88ed56231316427793c7fc4fa811a5f9.png"
alt="双缓冲" />
<figcaption aria-hidden="true">双缓冲</figcaption>
</figure>
</blockquote>
<p><strong>缓冲池</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/9d3e12c7b81c4e0da6859863a743e185.png"
alt="缓冲池" />
<figcaption aria-hidden="true">缓冲池</figcaption>
</figure>
</blockquote>
<h3 id="io-传输控制四种方式">I/O 传输控制四种方式</h3>
<p>四种控制方式：</p>
<ol type="1">
<li>轮询的可编程<span class="math inline">\(I/O\)</span>方式；</li>
<li>采用中断的可编程<span class="math inline">\(I/O\)</span>方式；</li>
<li>直接存储器访问方式（DMA方式）；</li>
<li><span class="math inline">\(I/O\)</span>通道方式；</li>
</ol>
<h3 id="通道定义分类">通道：定义、分类</h3>
<p>定义：</p>
<blockquote>
<ul>
<li>为<span class="math inline">\(CPU\)</span>减轻负担；</li>
<li><span
class="math inline">\(I/O\)</span>通道是一种特殊的处理机，只执行<span
class="math inline">\(I/O\)</span>指令，与<span
class="math inline">\(CPU\)</span>共享内存；</li>
</ul>
</blockquote>
<p>类型：</p>
<ol type="1">
<li><strong>字节多路通道</strong>：按字节交叉方式工作。可连接多个低速设备，按时间片轮转方式为多个设备服务；</li>
<li><strong>数组选择通道</strong>：可连接多个高速设备，一次只服务一个设备，通道利用率低；</li>
<li><strong>数组多路通道</strong>：将数组选择通道传输速率高和字节多路通道能使各子通道(设备)分时并发操作的优点相结合，传输速率高，通道利用率高；</li>
</ol>
<h3 id="磁盘调度fifosstfscan">磁盘调度：FIFO、SSTF、SCAN</h3>
<p><strong>FIFO（FCFS）</strong>和：<strong>SSTF</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/4e58cd05bd0a4d228fa270a8f076dde0.png"
alt="FCFSandSSTF" />
<figcaption aria-hidden="true">FCFSandSSTF</figcaption>
</figure>
</blockquote>
<p><strong>SCAN</strong>：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/9322a0e7c28b48e4af55fe75e13959e5.png"
alt="SCAN" />
<figcaption aria-hidden="true">SCAN</figcaption>
</figure>
</blockquote>
<h2 id="第七章文件管理">第七章：文件管理</h2>
<h3 id="文件分类">文件分类</h3>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/289eafbdf14d400098d5005e3e8499a5.png"
alt="文件分类" />
<figcaption aria-hidden="true">文件分类</figcaption>
</figure>
</blockquote>
<h3 id="文件逻辑结构流式和记录式">文件逻辑结构：流式和记录式</h3>
<p><strong>文件的逻辑结构</strong>：从用户观点出发所观察到的文件组织形式，是用户可以直接处理的数据及结构，
它独立于文件的物理特性。</p>
<p>流式和记录式文件：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/10c8528a804c499f8f8f4e308e5e81a1.png"
alt="流式和记录式" />
<figcaption aria-hidden="true">流式和记录式</figcaption>
</figure>
</blockquote>
<h3
id="文件目录fcb目录实现多级目录结构工作目录绝对路径和相对路径">文件目录：FCB、目录实现、多级目录结构、工作目录、绝对路径和相对路径</h3>
<p><strong>FCB</strong>：文件控制块</p>
<blockquote>
<ul>
<li>文件控制块是文件存在的<strong>标志</strong>；</li>
<li><strong>文件控制块</strong>的有序集合称为<strong>文件目录</strong>，每个<strong>文件控制块</strong>是一个文件目录项；</li>
<li>为了实现对<strong>文件目录</strong>的管理，通常将其以<strong>文件</strong>的形式保存在<strong>外存</strong>，这个文件就叫<strong>目录文件</strong>；</li>
</ul>
<figure>
<img
src="https://img-blog.csdnimg.cn/6f57041bb67b45e5b5e766f87198ec35.png"
alt="FCB" />
<figcaption aria-hidden="true">FCB</figcaption>
</figure>
</blockquote>
<p><strong>多级目录结构</strong>（树形目录结构）：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/ff9dccdab5524af993a8ef55e9cc6007.png"
alt="树形目录" />
<figcaption aria-hidden="true">树形目录</figcaption>
</figure>
<ul>
<li><strong>工作目录</strong>：每次访问文件都从根目录开始检索很麻烦，故为每个进程设置一个“<strong>当前目</strong>录”，又称<strong>“工作目录”</strong>；</li>
<li><strong>绝对路径名</strong>：文件的全路径名包括从<strong>根目录</strong>开始到<strong>文件</strong>为止的<strong>所有子目录</strong>
路径，即<strong>绝对路径</strong>名；</li>
<li><strong>相对路径名</strong>：从<strong>当前目录</strong>开始到文件，即使用<strong>相对路径名</strong>；</li>
</ul>
</blockquote>
<h3 id="i-结点磁盘索引结点和内存索引结点和文件之间的关系">i
结点、磁盘索引结点和内存索引结点和文件之间的关系</h3>
<p><span class="math inline">\(i\)</span>节点：</p>
<blockquote>
<p><strong>检索</strong>目录时，<strong>目录</strong>需调入内存。实际上检索只用到<strong>文件名</strong>；为了减少检索文件的系统开销，采用把文件名和文件描述信息分开的方法，使<strong>文件描述信息</strong>单独形成一个定长的<strong>数据结构</strong>，称为<strong>索引节点</strong>，简称为<span
class="math inline">\(i\)</span><strong>结点</strong>；</p>
<blockquote>
<p>索引节点可分为：</p>
<blockquote>
<p><strong>磁盘</strong>索引节点：存放在<strong>磁盘</strong>上的索引结点；</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/9f1fab498ebb463c9075969988aa2176.png"
alt="磁盘索引节点信息" />
<figcaption aria-hidden="true">磁盘索引节点信息</figcaption>
</figure>
<p><strong>内存</strong>索引节点：存放在<strong>内存</strong>中的索引结点；</p>
<figure>
<img
src="https://img-blog.csdnimg.cn/725fd89fb88243e69061b0d0a7218359.png"
alt="内存索引节点信息" />
<figcaption aria-hidden="true">内存索引节点信息</figcaption>
</figure>
</blockquote>
</blockquote>
</blockquote>
<h3 id="文件共享实现基于索引结点">文件共享实现：基于索引结点</h3>
<figure>
<img
src="https://img-blog.csdnimg.cn/5049130e1bd84756ad0379ffc58990b9.png"
alt="索引节点实现文件共享" />
<figcaption aria-hidden="true">索引节点实现文件共享</figcaption>
</figure>
<h2 id="第八章磁盘存储器的管理">第八章：磁盘存储器的管理</h2>
<h3
id="外存组织方式空闲块表位示图成组块链">外存组织方式：空闲块表、位示图、成组块链</h3>
<p>空闲块表：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/14728731a6b14c15a9d3a82a49299c8b.png"
alt="空闲块表" />
<figcaption aria-hidden="true">空闲块表</figcaption>
</figure>
</blockquote>
<p>位示图法：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/18533478d377424397c6c9943c85cb59.png"
alt="位示图法" />
<figcaption aria-hidden="true">位示图法</figcaption>
</figure>
</blockquote>
<p>成组块链：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/4e847de688ba4c95b1feac1566cd027e.png"
alt="成组块链" />
<figcaption aria-hidden="true">成组块链</figcaption>
</figure>
<figure>
<img
src="https://img-blog.csdnimg.cn/cc5ae36b5bcf4fbc966929dbb9567787.png"
alt="成组块链2" />
<figcaption aria-hidden="true">成组块链2</figcaption>
</figure>
</blockquote>
<h3
id="文件存储结构顺序文件串联文件即链接组织方式索引结构混合索引">文件存储结构：顺序文件、串联文件（即链接组织方式）、索引结构、混合索引</h3>
<p>连续组织方式：</p>
<blockquote>
<ul>
<li><p>每个文件分配一组相邻接的盘块；</p>
<p><strong>顺序文件</strong>：在采用连续组织方式时，可把逻辑文件中的记录顺序地存储到邻接的各物理盘块中，
形成的文件结构称为顺序文件结构，此时的物理文件称为<strong>顺序文件</strong>；</p></li>
</ul>
<p>优点：</p>
<blockquote>
<ul>
<li>顺序访问容易，记录顺序与磁盘块顺序一致；</li>
<li>顺序访问速度快，盘块位于同磁道或相邻磁道，磁头移动距离少；</li>
</ul>
</blockquote>
<p>缺点：</p>
<blockquote>
<ul>
<li>要求为一个文件分配连续的存储空间，会产生外部碎片，定期“紧凑”会耗费处理机时间；</li>
<li>必须事先知道文件的长度；</li>
<li>不能灵活地删除和插入记录，要移动相邻记录；</li>
<li>对于那些动态增长的文件很难分配空间；</li>
</ul>
</blockquote>
</blockquote>
<p>链接组织方式：</p>
<blockquote>
<p><strong>链接文件</strong>：采用<strong>链接组织方式</strong>时，可为文件分配多个不连续的盘块，再通过每个盘块上的<strong>链接指针</strong>，将同属于一个文件的多个离散的盘块链接成一个链表，由此所形成的物理文件称为<strong>链接文件</strong>；</p>
<p>优点：</p>
<blockquote>
<ul>
<li>消除了磁盘的外部碎片，提高了外存的利用率</li>
<li>对插入、删除和修改记录都非常容易</li>
<li>能适应文件的动态增长，无需事先知道文件的大小</li>
</ul>
</blockquote>
<p>两种链接方式：隐式链接，显式链接；</p>
</blockquote>
<p>混合组织方式：</p>
<blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/312d14ed0938456792269e2487b6233d.png"
alt="混合组织方式" />
<figcaption aria-hidden="true">混合组织方式</figcaption>
</figure>
</blockquote>
<h2 id="第九章操作系统接口">第九章：操作系统接口</h2>
<h3 id="系统调用的概念">系统调用的概念</h3>
<blockquote>
<ul>
<li>在OS中提供<strong>系统调用</strong>的目的，是使<strong>应用程序</strong>可以通过它间接<strong>调用</strong>OS中的相关过程，取得相应的服务。事实上，由OS向用户提供的所有功能，用户进
程都必须通过<strong>系统调用来获取</strong>；</li>
<li>每个OS中，通常都提供几十个甚至上百个<strong>系统调用</strong>；每一个系统调用都是
一个<strong>能完成特定功能的子程序</strong>；</li>
</ul>
<p>不同系统调用<strong>共同特点</strong>：</p>
<blockquote>
<ul>
<li>每个系统调用有一个自己的<strong>系统调用号</strong>；</li>
<li>每个系统调用有对应的<strong>可执行程序</strong>；</li>
<li>每个系统调用要求一定数量的<strong>输入参数和返回值</strong>；</li>
<li>整个系统有一个系统调用执行程序<strong>入口地址表</strong>；</li>
</ul>
</blockquote>
<ul>
<li><strong>系统调用子程序</strong>运行在<strong>系统态</strong>；</li>
<li><strong>应用程序</strong>运行在<strong>用户态</strong>，请求系统服务时，要通过<strong>中断机制</strong>，由<strong>用户态</strong>转换到<strong>系统态</strong>；</li>
<li>一个OS的所有系统调用，都通过<strong>同一个中断入口</strong>来实现；</li>
<li>系统调用也可以<strong>嵌套调用</strong>，但对嵌套调用的深度<strong>有一定的限制</strong>；</li>
</ul>
</blockquote>
<h3 id="访管指令">访管指令</h3>
<blockquote>
<p><strong>访管指令</strong>又称<strong>陷入指令</strong>（<span
class="math inline">\(trap\)</span>）。当用户进程或系统实用进程请求操作系统内核提供服务时，使用一条访管指令（<strong>系统调用命令</strong>）引起一次特殊中断，这种中断被称
为访管中断</p>
</blockquote>
<h3 id="系统调用实现过程">系统调用实现过程</h3>
<blockquote>
<p>应用程序请求系统服务（即要使用OS的<strong>系统调用</strong>）时，会产生一条<strong>访管指令</strong>，CPU执行此指令时发生<strong>中断</strong>，并将有关信号（所请求的<strong>系统调用号</strong>及参数）送给中断和陷入硬件机构，该机构收到信号后，启动相关的<strong>陷入</strong>（访管中断）处理程序进行处理，实现该<strong>系统调用</strong>所需要的功能；</p>
<blockquote>
<ol type="1">
<li>将处理机状态由<strong>用户态</strong>转为<strong>系统态</strong>；</li>
<li><strong>分析</strong>系统调用类型，<strong>转入</strong>相应的系统调用
处理子程序；</li>
<li>在系统调用处理子程序<strong>执行完</strong>后，应<strong>返回现场</strong>：返回被中断进程或新进程，继续往
下执行；</li>
</ol>
</blockquote>
<figure>
<img
src="https://img-blog.csdnimg.cn/ce94b144197a415cbff5da29268f381a.png"
alt="系统调用实现" />
<figcaption aria-hidden="true">系统调用实现</figcaption>
</figure>
</blockquote>
<h2 id="问题">问题：</h2>
<blockquote>
<p>Q1：生产者消费者问题的两个代码图片中两个P没反吗，不管生产者还是消费者，对buffer操作时，都应先将buffer上锁（互斥）再进行资源操作吗？</p>
<p>A1：<img
src="https://img-blog.csdnimg.cn/24330d338c5949409a3c5555db12b71f.png"
alt="A1" /></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Umbrella</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/05/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/OS/">http://example.com/2022/12/05/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/OS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Umbrella's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/">期末考试</a></div><div class="post_share"><div class="social-share" data-image="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/25/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/Principle%20Of%20Microcomputer/"><img class="next-cover" src="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">微机原理-期末考试</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/11/25/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/Principle%20Of%20Microcomputer/" title="微机原理-期末考试"><img class="cover" src="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-25</div><div class="title">微机原理-期末考试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://img-blog.csdnimg.cn/4500002a681d49c586c22a88e4ec5868.bmp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Umbrella</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/FeiUmbrella"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/FeiUmbrella" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/qq_51968155?spm=1000.2115.3001.5343" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=2199492464&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="mailto:2199492464@qq.com" target="_blank" title="Email"><i class="fas fa-envelope-open-text"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#os---%E5%A4%A7%E4%B8%89%E4%B8%8A%E5%A4%87%E8%80%83"><span class="toc-number">1.</span> <span class="toc-text">OS - 大三上备考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">第一章：绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9C%B0%E4%BD%8D%E4%BD%9C%E7%94%A8%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">操作系统的地位，作用，定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">多道程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%90%84%E8%87%AA%E7%89%B9%E7%82%B9%E5%8F%8A%E5%85%B6%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4%E6%89%B9%E5%A4%84%E7%90%86%E5%88%86%E6%97%B6%E5%AE%9E%E6%97%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">操作系统类型和各自特点及其适用范围：批处理、分时、实时</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">多道批处理系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">分时系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">实时系统</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.4.</span> <span class="toc-text">操作系统特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cpu-%E5%B7%A5%E4%BD%9C%E6%80%81%E7%B3%BB%E7%BB%9F%E6%80%81%E7%AE%A1%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9B%AE%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.5.</span> <span class="toc-text">CPU
工作态【系统态（管态）和用户态（目态）】及其转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">第二章：进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89%E5%BC%95%E5%85%A5%E5%8E%9F%E5%9B%A0%E7%89%B9%E5%BE%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">进程定义、引入原因、特征、分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pcb"><span class="toc-number">1.2.2.</span> <span class="toc-text">PCB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.3.</span> <span class="toc-text">进程基本状态及其转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%8E%9F%E8%AF%AD%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E9%98%BB%E5%A1%9E%E8%BF%9B%E7%A8%8B%E5%94%A4%E9%86%92"><span class="toc-number">1.2.4.</span> <span class="toc-text">进程控制：原语、进程创建、进程阻塞、进程唤醒</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%85%A8%E7%AB%A0%E8%8A%82"><span class="toc-number">1.2.5.</span> <span class="toc-text">进程同步全章节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.6.</span> <span class="toc-text">经典同步实现算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">生产者-消费者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">读者-写者问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%8C%BA%E6%B6%88%E6%81%AF%E7%BC%93%E5%86%B2%E4%BF%A1%E7%AE%B1%E7%AE%A1%E9%81%93"><span class="toc-number">1.2.7.</span> <span class="toc-text">进程通信：共享存储区、消息缓冲、信箱、管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9A%E4%B9%89%E5%BC%95%E5%85%A5%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.2.8.</span> <span class="toc-text">线程定义、引入原因</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.</span> <span class="toc-text">第三章：处理机调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%B1%82%E6%AC%A1%E5%92%8C%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9B%AE%E6%A0%87%E8%A1%A1%E9%87%8F%E6%A0%87%E5%87%86%E5%B9%B3%E5%9D%87%E5%91%A8%E8%BD%AC%E5%B9%B3%E5%9D%87%E5%8A%A0%E6%9D%83%E5%91%A8%E8%BD%AC"><span class="toc-number">1.3.1.</span> <span class="toc-text">调度层次和调度算法目标【衡量标准：平均周转、平均加权周转】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%E5%92%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">作业调度和进程调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%85%A8%E7%AB%A0%E8%8A%82"><span class="toc-number">1.3.3.</span> <span class="toc-text">死锁全章节</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">第四章：存储器管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88%E5%8E%9F%E7%90%86%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95%E9%A6%96%E6%AC%A1%E6%9C%80%E5%85%88%E6%9C%80%E4%BD%B3%E6%9C%80%E5%9D%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">固定分区、动态分区方案【原理、分区分配算法：首次（最先）、最佳、最坏】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E5%85%A8%E7%AB%A0%E8%8A%82%E4%B8%8D%E5%8C%85%E6%8B%AC%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E5%92%8C%E5%8F%8D%E7%BD%AE%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">页式存储管理方案【全章节（不包括：多级页表和反置页表）】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E5%BC%95%E5%85%A5%E5%8E%9F%E5%9B%A0%E6%AE%B5%E8%A1%A8%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.3.</span> <span class="toc-text">段式存储管理方案：引入原因、段表、段页式存储管理方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.5.</span> <span class="toc-text">第五章：虚拟存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%8E%9F%E5%9B%A0%E5%AE%9A%E4%B9%89%E5%A4%A7%E5%B0%8F%E7%89%B9%E5%BE%81%E7%90%86%E8%AE%BA%E4%BE%9D%E6%8D%AE"><span class="toc-number">1.5.1.</span> <span class="toc-text">引入原因、定义、大小、特征、理论依据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E8%B0%83%E9%A1%B5%E6%97%B6%E6%9C%BA%E4%BD%95%E5%A4%84%E8%B0%83%E9%A1%B5%E6%8A%80%E6%9C%AF%E6%94%AF%E6%8C%81%E7%A1%AC%E4%BB%B6%E8%BD%AF%E4%BB%B6%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">请求分页：调页时机、何处调页、技术支持【硬件、软件】、缺页中断处理过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95optfifolru"><span class="toc-number">1.5.3.</span> <span class="toc-text">淘汰算法：OPT、FIFO、LRU</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.6.</span> <span class="toc-text">第六章：输入输出系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="toc-number">1.6.1.</span> <span class="toc-text">I&#x2F;O 系统组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.2.</span> <span class="toc-text">设备分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="toc-number">1.6.3.</span> <span class="toc-text">设备独立性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spooling-%E6%8A%80%E6%9C%AF"><span class="toc-number">1.6.4.</span> <span class="toc-text">Spooling 技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%88%86%E9%85%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B"><span class="toc-number">1.6.5.</span> <span class="toc-text">设备分配：数据结构、考虑因素、分配过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%8A%80%E6%9C%AF%E5%BC%95%E5%85%A5%E5%8E%9F%E5%9B%A0%E5%8D%95%E7%BC%93%E5%86%B2%E5%8F%8C%E7%BC%93%E5%86%B2%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">1.6.6.</span> <span class="toc-text">缓冲技术：引入原因、单缓冲、双缓冲、缓冲池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io-%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.7.</span> <span class="toc-text">I&#x2F;O 传输控制四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%AE%9A%E4%B9%89%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.8.</span> <span class="toc-text">通道：定义、分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6fifosstfscan"><span class="toc-number">1.6.9.</span> <span class="toc-text">磁盘调度：FIFO、SSTF、SCAN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86"><span class="toc-number">1.7.</span> <span class="toc-text">第七章：文件管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB"><span class="toc-number">1.7.1.</span> <span class="toc-text">文件分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%E6%B5%81%E5%BC%8F%E5%92%8C%E8%AE%B0%E5%BD%95%E5%BC%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">文件逻辑结构：流式和记录式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95fcb%E7%9B%AE%E5%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-number">1.7.3.</span> <span class="toc-text">文件目录：FCB、目录实现、多级目录结构、工作目录、绝对路径和相对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-%E7%BB%93%E7%82%B9%E7%A3%81%E7%9B%98%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9%E5%92%8C%E5%86%85%E5%AD%98%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9%E5%92%8C%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.7.4.</span> <span class="toc-text">i
结点、磁盘索引结点和内存索引结点和文件之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E7%BB%93%E7%82%B9"><span class="toc-number">1.7.5.</span> <span class="toc-text">文件共享实现：基于索引结点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">第八章：磁盘存储器的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E5%AD%98%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E7%A9%BA%E9%97%B2%E5%9D%97%E8%A1%A8%E4%BD%8D%E7%A4%BA%E5%9B%BE%E6%88%90%E7%BB%84%E5%9D%97%E9%93%BE"><span class="toc-number">1.8.1.</span> <span class="toc-text">外存组织方式：空闲块表、位示图、成组块链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E9%A1%BA%E5%BA%8F%E6%96%87%E4%BB%B6%E4%B8%B2%E8%81%94%E6%96%87%E4%BB%B6%E5%8D%B3%E9%93%BE%E6%8E%A5%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E6%B7%B7%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">文件存储结构：顺序文件、串联文件（即链接组织方式）、索引结构、混合索引</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.9.</span> <span class="toc-text">第九章：操作系统接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.9.1.</span> <span class="toc-text">系统调用的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E7%AE%A1%E6%8C%87%E4%BB%A4"><span class="toc-number">1.9.2.</span> <span class="toc-text">访管指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">1.9.3.</span> <span class="toc-text">系统调用实现过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text">问题：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/05/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/OS/" title="操作系统-期末考试"><img src="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统-期末考试"/></a><div class="content"><a class="title" href="/2022/12/05/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/OS/" title="操作系统-期末考试">操作系统-期末考试</a><time datetime="2022-12-05T07:40:00.000Z" title="发表于 2022-12-05 15:40:00">2022-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/25/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/Principle%20Of%20Microcomputer/" title="微机原理-期末考试"><img src="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="微机原理-期末考试"/></a><div class="content"><a class="title" href="/2022/11/25/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/Principle%20Of%20Microcomputer/" title="微机原理-期末考试">微机原理-期末考试</a><time datetime="2022-11-25T10:06:00.000Z" title="发表于 2022-11-25 18:06:00">2022-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/Math%20Knowledge%20Points/" title="Math Knowledge Points"><img src="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Math Knowledge Points"/></a><div class="content"><a class="title" href="/2022/11/21/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/Math%20Knowledge%20Points/" title="Math Knowledge Points">Math Knowledge Points</a><time datetime="2022-11-20T16:00:00.000Z" title="发表于 2022-11-21 00:00:00">2022-11-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/22/%E5%82%8D%E8%BA%AB%E4%BA%8C%E4%B8%89-%E6%8A%80%E6%9C%AF/hello-world/" title="English words"><img src="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="English words"/></a><div class="content"><a class="title" href="/2022/10/22/%E5%82%8D%E8%BA%AB%E4%BA%8C%E4%B8%89-%E6%8A%80%E6%9C%AF/hello-world/" title="English words">English words</a><time datetime="2022-10-22T01:28:04.000Z" title="发表于 2022-10-22 09:28:04">2022-10-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/22/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/English-worlds/" title="English words"><img src="https://img-blog.csdnimg.cn/28aff0e4ab5d403581251344fd4c0831.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="English words"/></a><div class="content"><a class="title" href="/2022/10/22/%E4%BD%95%E5%BD%93%E5%85%B1%E5%89%AA-%E7%A0%94%E7%A9%B6%E7%94%9F%E8%80%83%E8%AF%95%E5%A4%87%E8%80%83/English-worlds/" title="English words">English words</a><time datetime="2022-10-22T01:28:04.000Z" title="发表于 2022-10-22 09:28:04">2022-10-22</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Umbrella</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container').forEach(node => {
            if (node.hasAttribute('display')) {
              btf.wrap(node, 'div', { class: 'mathjax-overflow' })
            } else {
              btf.wrap(node, 'span', { class: 'mathjax-overflow' })
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>